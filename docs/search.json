[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "A mon sujet",
    "section": "",
    "text": "Je m’appelle JAMIN Mathilde, je suis étudiante Master 1 Econométrie Appliquée à l’IAE de Nantes."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Blog de Mathilde JAMIN",
    "section": "",
    "text": "Bienvenue sur mon blog !\nVous trouverez ici des exercices ainsi qu’un package réalisé lors du cours “R avancé et Git” donné par Monsieur Nedellec dans le cadre du Master 1 ECAP à l’IAE de Nantes.\nLe thème des exercices ainsi que du package porte sur les Jeux Olympiques de Paris 2024.\n\n\n\n\n\n\n\n\n  \n\n\n\n\nExercice 1\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n  \n\n\n\n\nExercice 2\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n  \n\n\n\n\nExercice 3\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n  \n\n\n\n\nExercice 4\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n  \n\n\n\n\nExercice final\n\n\n\n\n\n\n\nnews\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\n\n\nMar 10, 2024\n\n\nJAMIN Mathilde\n\n\n\n\n\n\n  \n\n\n\n\nInformations\n\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\n\n\nMar 10, 2024\n\n\nJAMIN Mathilde\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Exercice final",
    "section": "",
    "text": "Ce package nous permet d’obtenir les prévisions métérologiques à sept jours. Pour ce faire, veillez saisir une adresse complète telle que “9 Quai Henri Barbusse, Nantes, France” ou encore une adresse plus simple “Sacré Coeur”. Vous pouvez également entrer des coordonnées GPS (latitude, longitude) comme “127,86, -77,98”.\nUne fois ces informations entrées, vous pourrez visualiser les prévisions métérologiques, un graphique s’affichera également.\nPar exemple :\n\nget_forecast(\"Sacre Coeur\")\n\n\n\n\n\nWarning: le package 'jsonlite' a été compilé avec la version R 4.3.2\n\n\n\nlibrary(olympicsWeather)\n\n\nget_forecast(\"Stade de France\")\n\nPassing 1 address to the ArcGIS single address geocoder\n\n\nQuery completed in: 1.6 seconds\n\n\n\n\n\n# A tibble: 168 × 5\n   date_heure          temperature_celsius temperature_ressentie_celsius\n   &lt;dttm&gt;                            &lt;dbl&gt;                         &lt;dbl&gt;\n 1 2024-03-07 00:00:00                 4.6                           2.5\n 2 2024-03-07 01:00:00                 4.1                           1.6\n 3 2024-03-07 02:00:00                 3.6                           1.3\n 4 2024-03-07 03:00:00                 3                             0.5\n 5 2024-03-07 04:00:00                 2.7                           0.2\n 6 2024-03-07 05:00:00                 2.5                          -0.1\n 7 2024-03-07 06:00:00                 2.3                          -0.3\n 8 2024-03-07 07:00:00                 2.4                          -0.2\n 9 2024-03-07 08:00:00                 3.7                           1.2\n10 2024-03-07 09:00:00                 5.8                           3.1\n# ℹ 158 more rows\n# ℹ 2 more variables: precipitation_proba &lt;int&gt;, precipitation &lt;dbl&gt;\n\n\n\nget_forecast(\"Tahiti\")\n\nPassing 1 address to the ArcGIS single address geocoder\n\n\nQuery completed in: 0.2 seconds\n\n\n\n\n\n# A tibble: 168 × 5\n   date_heure          temperature_celsius temperature_ressentie_celsius\n   &lt;dttm&gt;                            &lt;dbl&gt;                         &lt;dbl&gt;\n 1 2024-03-07 00:00:00                24.3                          27.8\n 2 2024-03-07 01:00:00                22.9                          26.8\n 3 2024-03-07 02:00:00                22.5                          25.3\n 4 2024-03-07 03:00:00                22.3                          24.7\n 5 2024-03-07 04:00:00                22                            24.5\n 6 2024-03-07 05:00:00                22.3                          24.1\n 7 2024-03-07 06:00:00                21.7                          24.2\n 8 2024-03-07 07:00:00                21.4                          23.6\n 9 2024-03-07 08:00:00                20.6                          22.4\n10 2024-03-07 09:00:00                20.9                          23.1\n# ℹ 158 more rows\n# ℹ 2 more variables: precipitation_proba &lt;int&gt;, precipitation &lt;dbl&gt;\n\n\n\nget_forecast(c(43.276703, 5.334791))\n\n\n\n\n# A tibble: 168 × 5\n   date_heure          temperature_celsius temperature_ressentie_celsius\n   &lt;dttm&gt;                            &lt;dbl&gt;                         &lt;dbl&gt;\n 1 2024-03-07 00:00:00                 8.9                           3.8\n 2 2024-03-07 01:00:00                 8.5                           3.7\n 3 2024-03-07 02:00:00                 7.8                           3.7\n 4 2024-03-07 03:00:00                 6.6                           2.7\n 5 2024-03-07 04:00:00                 7.1                           3.2\n 6 2024-03-07 05:00:00                 6.7                           3.3\n 7 2024-03-07 06:00:00                 7.3                           3.6\n 8 2024-03-07 07:00:00                 7.7                           4.8\n 9 2024-03-07 08:00:00                 8.4                           6.1\n10 2024-03-07 09:00:00                 9.3                           7.2\n# ℹ 158 more rows\n# ℹ 2 more variables: precipitation_proba &lt;int&gt;, precipitation &lt;dbl&gt;"
  },
  {
    "objectID": "posts/post-with-code/index.html#librairie-olympicsweather",
    "href": "posts/post-with-code/index.html#librairie-olympicsweather",
    "title": "Exercice final",
    "section": "",
    "text": "Ce package nous permet d’obtenir les prévisions métérologiques à sept jours. Pour ce faire, veillez saisir une adresse complète telle que “9 Quai Henri Barbusse, Nantes, France” ou encore une adresse plus simple “Sacré Coeur”. Vous pouvez également entrer des coordonnées GPS (latitude, longitude) comme “127,86, -77,98”.\nUne fois ces informations entrées, vous pourrez visualiser les prévisions métérologiques, un graphique s’affichera également.\nPar exemple :\n\nget_forecast(\"Sacre Coeur\")\n\n\n\n\n\nWarning: le package 'jsonlite' a été compilé avec la version R 4.3.2\n\n\n\nlibrary(olympicsWeather)\n\n\nget_forecast(\"Stade de France\")\n\nPassing 1 address to the ArcGIS single address geocoder\n\n\nQuery completed in: 1.6 seconds\n\n\n\n\n\n# A tibble: 168 × 5\n   date_heure          temperature_celsius temperature_ressentie_celsius\n   &lt;dttm&gt;                            &lt;dbl&gt;                         &lt;dbl&gt;\n 1 2024-03-07 00:00:00                 4.6                           2.5\n 2 2024-03-07 01:00:00                 4.1                           1.6\n 3 2024-03-07 02:00:00                 3.6                           1.3\n 4 2024-03-07 03:00:00                 3                             0.5\n 5 2024-03-07 04:00:00                 2.7                           0.2\n 6 2024-03-07 05:00:00                 2.5                          -0.1\n 7 2024-03-07 06:00:00                 2.3                          -0.3\n 8 2024-03-07 07:00:00                 2.4                          -0.2\n 9 2024-03-07 08:00:00                 3.7                           1.2\n10 2024-03-07 09:00:00                 5.8                           3.1\n# ℹ 158 more rows\n# ℹ 2 more variables: precipitation_proba &lt;int&gt;, precipitation &lt;dbl&gt;\n\n\n\nget_forecast(\"Tahiti\")\n\nPassing 1 address to the ArcGIS single address geocoder\n\n\nQuery completed in: 0.2 seconds\n\n\n\n\n\n# A tibble: 168 × 5\n   date_heure          temperature_celsius temperature_ressentie_celsius\n   &lt;dttm&gt;                            &lt;dbl&gt;                         &lt;dbl&gt;\n 1 2024-03-07 00:00:00                24.3                          27.8\n 2 2024-03-07 01:00:00                22.9                          26.8\n 3 2024-03-07 02:00:00                22.5                          25.3\n 4 2024-03-07 03:00:00                22.3                          24.7\n 5 2024-03-07 04:00:00                22                            24.5\n 6 2024-03-07 05:00:00                22.3                          24.1\n 7 2024-03-07 06:00:00                21.7                          24.2\n 8 2024-03-07 07:00:00                21.4                          23.6\n 9 2024-03-07 08:00:00                20.6                          22.4\n10 2024-03-07 09:00:00                20.9                          23.1\n# ℹ 158 more rows\n# ℹ 2 more variables: precipitation_proba &lt;int&gt;, precipitation &lt;dbl&gt;\n\n\n\nget_forecast(c(43.276703, 5.334791))\n\n\n\n\n# A tibble: 168 × 5\n   date_heure          temperature_celsius temperature_ressentie_celsius\n   &lt;dttm&gt;                            &lt;dbl&gt;                         &lt;dbl&gt;\n 1 2024-03-07 00:00:00                 8.9                           3.8\n 2 2024-03-07 01:00:00                 8.5                           3.7\n 3 2024-03-07 02:00:00                 7.8                           3.7\n 4 2024-03-07 03:00:00                 6.6                           2.7\n 5 2024-03-07 04:00:00                 7.1                           3.2\n 6 2024-03-07 05:00:00                 6.7                           3.3\n 7 2024-03-07 06:00:00                 7.3                           3.6\n 8 2024-03-07 07:00:00                 7.7                           4.8\n 9 2024-03-07 08:00:00                 8.4                           6.1\n10 2024-03-07 09:00:00                 9.3                           7.2\n# ℹ 158 more rows\n# ℹ 2 more variables: precipitation_proba &lt;int&gt;, precipitation &lt;dbl&gt;"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Informations",
    "section": "",
    "text": "Merci d’avoir visité mon blog !"
  },
  {
    "objectID": "posts/post-with-code/exercice 1.html",
    "href": "posts/post-with-code/exercice 1.html",
    "title": "blog",
    "section": "",
    "text": "Ce premier exercice a pour but de nettoyer une base de données ainsi que d’en extraire les informations principales. Nous avons également appris à utiliser le package geocoder nous permettant d’effectuer des calculs à partir de lieux précis. Ceci nous sera utile pour l’exercice final.\n\n\n\n\n\ndata_ex &lt;- read.csv2(\"C:/Users/mathi/OneDrive/Documents/M1 ECAP/Semestre 2/R avancé et Git/R_avancé/données/paris2024.csv\")\n\n\ncolnames_data&lt;-colnames(data_ex)\n\ntypes_col&lt;-sapply(data_ex, class)\n\nmessage(\"Noms des colonnes : \", paste(colnames_data, collapse = \", \"))\n\nNoms des colonnes : geo_point, nom, sites_olympiques_paralympiques, sports\n\nmessage(\"Nature des colonnes : \", paste(types_col, collapse = \", \"))\n\nNature des colonnes : character, character, character, character\n\nmessage(\"Nombre de lignes dans la data.frame : \", nrow(data_ex))\n\nNombre de lignes dans la data.frame : 31\n\ndim(data_ex)\n\n[1] 31  4\n\n\nIl y a 4 colonnes dans notre jeu de données, elles portent les noms suivants :\n- geo_point\n- nom\n- sites_olympiques\n- sports\nElles sont toutes les 4 de type caractère.\nDe plus, notre base contient 31 lignes.\n\n\n\n\n\n\n\nnb_sites_olympiques &lt;- sum(data_ex$sites_olympiques_paralympiques == \"Site olympique\", na.rm = TRUE)\n\nnb_sites_olympiques\n\n[1] 10\n\n\nIl y a 10 sites olympiques.\n\n\n\n\n\n\n\nnb_sites_paralympiques &lt;- sum (data_ex$sites_olympiques_paralympiques == \"Site paralympique\", na.rm = TRUE)\n\nnb_sites_paralympiques\n\n[1] 3\n\n\nIl y a 3 sites paralympiques.\n\nnb_sites_olympiques_paralympiques &lt;- sum(data_ex$sites_olympiques_paralympiques == \"Site olympique,Site paralympique\", na.rm = TRUE)\n\nnb_sites_olympiques_paralympiques\n\n[1] 16\n\n\nIl y a 16 sites qui sont olympiques et paralympiques.\n\n\n\n\n\n\n\ndata_ex$nb_sports &lt;- strsplit (as.character(data_ex$sports), \",\")\n\nsites_plusieurs_sports &lt;- data_ex[sapply(data_ex$nb_sports, length)&gt;1,]\n\nsites_plusieurs_sports$nom \n\n [1] \"Stade de France\"                                \n [2] \"Vélodrome National de Saint-Quentin-en-Yvelines\"\n [3] \"Stade Roland Garros\"                            \n [4] \"Arena Paris Sud 4 (Porte de Versailles)\"        \n [5] \"Pont d'Iéna\"                                    \n [6] \"Arena Bercy\"                                    \n [7] \"Arena Paris nord\"                               \n [8] \"Arena Paris Sud 6 (Porte de Versailles)\"        \n [9] \"Stade de la Concorde\"                           \n[10] \"Arena Champs de Mars\"                           \n[11] \"La Défense Arena\"                               \n[12] \"Stade nautique\"                                 \n[13] \"Arena Paris Sud 1 (Porte de Versailles)\"        \n[14] \"Stade Tour Eiffel\"                              \n[15] \"Arena La Chapelle\"                              \n[16] \"Centre aquatique\"                               \n[17] \"Château de Versailles\"                          \n[18] \"Grand Palais\"                                   \n[19] \"Invalides\"                                      \n\n\nIl y a donc 19 sites qui accueillent plusieurs disciplines sportives.\n\n\n\n\n\n\n\nsites_para &lt;- data_ex[data_ex$sites_olympiques_paralympiques == \"Site paralympique\",]\n\nsites_para$sports \n\n[1] \"Para cyclisme sur route\" \"Goalball\"               \n[3] \"Para athlétisme\"        \n\n\nLes sites paralympiques accueillent donc 3 disciplines.\n\nsites_para_olym &lt;- data_ex[data_ex$sites_olympiques_paralympiques == \"Site olympique,Site paralympique\",]\n\nsites_para_olym$sports\n\n [1] \"Athlétisme,Para athlétisme,Rugby\"                                \n [2] \"Cyclisme sur piste,Para cyclisme sur piste\"                      \n [3] \"Tennis,Tennis fauteuil,Boxe\"                                     \n [4] \"Tennis de table,Para tennis de table\"                            \n [5] \"Basketball,Basket fauteuil,Gymnastique artistique,trampoline\"    \n [6] \"Boxe,Escrime,Pentathlon moderne,Volley-ball assis\"               \n [7] \"Haltérophilie,Handball,Goalball\"                                 \n [8] \"Judo,Para judo,Lutte,Rugby fauteuil\"                             \n [9] \"Natation,Para natation,Water-polo\"                               \n[10] \"Canoë,Para canoë,Aviron,Para aviron\"                             \n[11] \"Volleyball,Boccia\"                                               \n[12] \"Volleyball de plage,Cécifoot\"                                    \n[13] \"Badminton,Para Badminton,Gymnastique rythmique,Para powerlifting\"\n[14] \"Sports équestres,Para équitation,Pentathlon moderne\"             \n[15] \"Escrime,Escrime fauteuil,Taekwondo,Para taekwondo\"               \n[16] \"Tir à l'arc,Para tir à l'arc,Athlétisme,Cyclisme sur route\"      \n\n\nIci, les sites olympiques et paralympiques accueillent différentes disciplines comme :\n- Tennis fauteil\n- Para tennis de table\n- Basket fauteil\n- Volley-ball assis\n- Para judo\n- Rugby fauteil\n- Para natation\n- Para canoe\n- Para aviron\n- Cécifoot\n- Para badminton\n- Para power liftting\n- Para equitation\n- Escrime fauteil\n- Para taekwondo\n- Para tir à l’arc\nNous aurions pu aussi créer un code qui prenait seulement les noms “para” et “fauteil” pour une utilisation plus optimal. Cependant, les disciplines cécifoot et volley-ball assis auraient surement été oublié.\n\n\n\n\n\n\n\nsites_plusieurs_sports$nb_sports \n\nIci les sites numéro 6, 7, 9, 10, 12, 15, 18 et 19 accueillent au moins 4 disciplines différentes.\n\nsites_plusieurs_sports$nom\n\nCes sites sont respectivement les suivants :\n- Arena Bercy\n- Arena Paris nord\n- Stade de la Concorde\n- Arena Champs de Mars\n- Stade nautique\n- Arena La Chapelle\n- Grand Palais\n- Invalides\n\n\n\n\n\n\n\n\n\n\ntous_les_sports &lt;- unique(unlist(data_ex$nb_sports))\n\nnb_sites_discipline &lt;- numeric(length = length(tous_les_sports))\n\nfor (i in seq_along(tous_les_sports)) {\n\n  nb_sites_discipline[i] &lt;- sum(sapply(data_ex$nb_sports, function(x) tous_les_sports[i] %in%x))\n\n  \n\n}\n\ndiscipline_max_sites &lt;-tous_les_sports[which.max(nb_sites_discipline)]\n\nsites_discipline_max &lt;-data_ex[sapply(data_ex$nb_sports, function (x) discipline_max_sites %in% x),]\n\n\ndiscipline_max_sites\n\n[1] \"Athlétisme\"\n\nsites_discipline_max$nom \n\n[1] \"Stade de France\"         \"Hôtel de ville de Paris\"\n[3] \"Pont d'Iéna\"             \"Invalides\"              \n\n\nLa discipline qui aura lieu sur le plus grand nombre de sites est l’athlétisme. Cette dernière aura lieu au Stade de France, à l’Hotel de ville de Paris, au Pont d’Iéna ainsi qu’aux Invalides.\n\n\n\n\n\n\nTout d’abord, nous divisons la colonne geo_point en deux colonnes distinctes comprennant les latitudes et longitudes de chaque sites puis nous transformons ces dernières en valeur numérique.\n\nlibrary(geosphere)\n\nlibrary(tidyverse)\n\nWarning: le package 'stringr' a été compilé avec la version R 4.3.2\n\n\n\ndata_coordonnees &lt;- data.frame(do.call('rbind', strsplit(as.character(data_ex$geo_point), ',')))\n\ncolnames(data_coordonnees) &lt;- c(\"latitude\", \"longitude\")\n\ndata_ex &lt;- cbind(data_ex, data_coordonnees)\n\nstr(data_ex)\n\ndata_ex$longitude &lt;- as.numeric(data_ex$longitude)\n\ndata_ex$latitude &lt;- as.numeric(data_ex$latitude)\n\nEnsuite, nous récupérons les données.\n\ncoordonnees &lt;- data_ex[, c(\"latitude\", \"longitude\")]\n\nPuis nous faisons la même chose avec le nom des sites.\n\nnoms_sites &lt;- data_ex$nom\n\nA présent, nous allons initialiser le nom des sites pour retrouver ceux qui sont les plus proches.\n\nsite1 &lt;- NULL\n\nsite2 &lt;- NULL\n\ndistance_min &lt;- Inf\n\nMaintenant, nous créeons une boucle afin de répondre à la question.\n\nfor (i in 1:(nrow(coordonnees) - 1)) {\n\n  for (j in (i + 1):nrow(coordonnees)) {\n\n    #Nettoyons et convertissons les noms des sites en minuscules (sinon beug)\n\n    nom_site_i &lt;- tolower(trimws(noms_sites[i]))\n\n    nom_site_j &lt;- tolower(trimws(noms_sites[j]))\n\n    \n\n    #Calculons la distance entre les sites i et j\n\n    distance &lt;- distHaversine(coordonnees[c(i, j), , drop = FALSE])\n\n    \n\n    cat(\"Distance entre\", nom_site_i, \"et\", nom_site_j, \":\", distance, \"mètres\\n\")\n\n    \n\n    #Mettons à jour les noms des sites les plus proches si la distance est plus petite entre ces couples\n\n    if (distance &lt; distance_min) {\n\n      distance_min &lt;- distance\n\n      site1 &lt;- nom_site_i\n\n      site2 &lt;- nom_site_j\n\n      \n\n      cat(\"Nouvelle paire trouvée :\", site1, \"et\", site2, \"avec distance :\", distance_min, \"mètres\\n\")\n\n    }\n\n  }\n\n}\n\nNous allons à présent afficher nos résultats.\n\nif (!is.null(site1) && !is.null(site2)) {\n\n  cat(\"Les deux sites les plus proches sont :\", site1, \"et\", site2, \"\\n\")\n\n  cat(\"La distance entre ces deux sites est :\", distance_min, \"mètres\\n\")\n\n} else {\n\n  cat(\"Aucun résultat trouvé. Vérifiez vos données.\\n\")\n\n}\n\nLes deux sites les plus proches sont : vélodrome national de saint-quentin-en-yvelines et stade bmx de saint-quentin-en-yvelines \nLa distance entre ces deux sites est : 91.69166 mètres\n\n\nLes deux sites les plus proches se trouvent à Saint-Quentin-en-Yvelines et ce sont le Vélodrome National ainsi que le Stade BMX avec une distance de 91,69 mètres.\n\n\n\n\n\n\nNous procédons de la même manière pour trouver les deux sites les plus éloignés.\n\nsite3 &lt;- NULL\n\nsite4 &lt;- NULL\n\ndistance_max &lt;- 0\n\n\nfor (x in 1:(nrow(coordonnees) - 1)) {\n\n  for (y in (x + 1):nrow(coordonnees)) {\n\n    #Nettoyons et convertissons les noms des sites en minuscules\n\n    nom_site_x &lt;- tolower(trimws(noms_sites[x]))\n\n    nom_site_y &lt;- tolower(trimws(noms_sites[y]))\n\n    \n\n    #Calculons la distance entre les sites x et y\n\n    distance &lt;- distHaversine(coordonnees[c(x, y), , drop = FALSE])\n\n    \n\n    cat(\"Distance entre\", nom_site_x, \"et\", nom_site_y, \":\", distance, \"mètres\\n\")\n\n    \n\n    #Mettons à jour les noms des sites les plus éloignés si la distance est plus grande\n\n    if (distance &gt; distance_max) {\n\n      distance_max &lt;- distance\n\n      site3 &lt;- nom_site_x\n\n      site4 &lt;- nom_site_y\n\n      \n\n      cat(\"Nouvelle paire trouvée :\", site3, \"et\", site4, \"avec distance :\", distance_max, \"mètres\\n\")\n\n    }\n\n  }\n\n}\n\n\nif (!is.null(site3) && !is.null(site4)) {\n\n  cat(\"Les deux sites les plus éloignés sont :\", site3, \"et\", site4, \"\\n\")\n\n  cat(\"La distance entre ces deux sites est :\", distance_max, \"mètres\\n\")\n\n} else {\n\n  cat(\"Aucun résultat trouvé. Vérifiez vos données.\\n\")\n\n}\n\nLes deux sites les plus éloignés sont : stade nautique et colline d'elancourt \nLa distance entre ces deux sites est : 74882.55 mètres\n\n\nIci, les deux sites les plus éloignés sont le Stade Nautique et la Colline d’Elancourt avec une distance de 74882 mètres soit 74km.\n\n\n\n\n\n\nNous allons tout d’abord calculer la moyenne des latitudes et longitudes afin de trouver le barycentre.\n\nlatitude_bary &lt;- mean(coordonnees$latitude)\n\nlongitude_bary &lt;- mean(coordonnees$longitude)\n\nA présent, nous affichons ces valeurs.\n\ncat(\"Latitude du barycentre :\", latitude_bary, \"\\n\")\n\nLatitude du barycentre : 48.86684 \n\ncat(\"Longitude du barycentre :\", longitude_bary, \"\\n\")\n\nLongitude du barycentre : 2.29757 \n\n\nLa latitude du barycentre est de 48,86684 et la longitude de 2,29757.\n\nlatitude &lt;- 48.858844\n\nlongitude &lt;- 2.294350\n\nEn faisant des recherches internet, ceci se trouve Place du Trocadéro et du 11 novembre, proche du Palais de Chaillot.\nEn effet, il fallait télécharger une clé google maps or je n’ai pas réussi à faire cela."
  },
  {
    "objectID": "posts/post-with-code/exercice 1.html#exercice-1",
    "href": "posts/post-with-code/exercice 1.html#exercice-1",
    "title": "blog",
    "section": "",
    "text": "Ce premier exercice a pour but de nettoyer une base de données ainsi que d’en extraire les informations principales. Nous avons également appris à utiliser le package geocoder nous permettant d’effectuer des calculs à partir de lieux précis. Ceci nous sera utile pour l’exercice final.\n\n\n\n\n\ndata_ex &lt;- read.csv2(\"C:/Users/mathi/OneDrive/Documents/M1 ECAP/Semestre 2/R avancé et Git/R_avancé/données/paris2024.csv\")\n\n\ncolnames_data&lt;-colnames(data_ex)\n\ntypes_col&lt;-sapply(data_ex, class)\n\nmessage(\"Noms des colonnes : \", paste(colnames_data, collapse = \", \"))\n\nNoms des colonnes : geo_point, nom, sites_olympiques_paralympiques, sports\n\nmessage(\"Nature des colonnes : \", paste(types_col, collapse = \", \"))\n\nNature des colonnes : character, character, character, character\n\nmessage(\"Nombre de lignes dans la data.frame : \", nrow(data_ex))\n\nNombre de lignes dans la data.frame : 31\n\ndim(data_ex)\n\n[1] 31  4\n\n\nIl y a 4 colonnes dans notre jeu de données, elles portent les noms suivants :\n- geo_point\n- nom\n- sites_olympiques\n- sports\nElles sont toutes les 4 de type caractère.\nDe plus, notre base contient 31 lignes.\n\n\n\n\n\n\n\nnb_sites_olympiques &lt;- sum(data_ex$sites_olympiques_paralympiques == \"Site olympique\", na.rm = TRUE)\n\nnb_sites_olympiques\n\n[1] 10\n\n\nIl y a 10 sites olympiques.\n\n\n\n\n\n\n\nnb_sites_paralympiques &lt;- sum (data_ex$sites_olympiques_paralympiques == \"Site paralympique\", na.rm = TRUE)\n\nnb_sites_paralympiques\n\n[1] 3\n\n\nIl y a 3 sites paralympiques.\n\nnb_sites_olympiques_paralympiques &lt;- sum(data_ex$sites_olympiques_paralympiques == \"Site olympique,Site paralympique\", na.rm = TRUE)\n\nnb_sites_olympiques_paralympiques\n\n[1] 16\n\n\nIl y a 16 sites qui sont olympiques et paralympiques.\n\n\n\n\n\n\n\ndata_ex$nb_sports &lt;- strsplit (as.character(data_ex$sports), \",\")\n\nsites_plusieurs_sports &lt;- data_ex[sapply(data_ex$nb_sports, length)&gt;1,]\n\nsites_plusieurs_sports$nom \n\n [1] \"Stade de France\"                                \n [2] \"Vélodrome National de Saint-Quentin-en-Yvelines\"\n [3] \"Stade Roland Garros\"                            \n [4] \"Arena Paris Sud 4 (Porte de Versailles)\"        \n [5] \"Pont d'Iéna\"                                    \n [6] \"Arena Bercy\"                                    \n [7] \"Arena Paris nord\"                               \n [8] \"Arena Paris Sud 6 (Porte de Versailles)\"        \n [9] \"Stade de la Concorde\"                           \n[10] \"Arena Champs de Mars\"                           \n[11] \"La Défense Arena\"                               \n[12] \"Stade nautique\"                                 \n[13] \"Arena Paris Sud 1 (Porte de Versailles)\"        \n[14] \"Stade Tour Eiffel\"                              \n[15] \"Arena La Chapelle\"                              \n[16] \"Centre aquatique\"                               \n[17] \"Château de Versailles\"                          \n[18] \"Grand Palais\"                                   \n[19] \"Invalides\"                                      \n\n\nIl y a donc 19 sites qui accueillent plusieurs disciplines sportives.\n\n\n\n\n\n\n\nsites_para &lt;- data_ex[data_ex$sites_olympiques_paralympiques == \"Site paralympique\",]\n\nsites_para$sports \n\n[1] \"Para cyclisme sur route\" \"Goalball\"               \n[3] \"Para athlétisme\"        \n\n\nLes sites paralympiques accueillent donc 3 disciplines.\n\nsites_para_olym &lt;- data_ex[data_ex$sites_olympiques_paralympiques == \"Site olympique,Site paralympique\",]\n\nsites_para_olym$sports\n\n [1] \"Athlétisme,Para athlétisme,Rugby\"                                \n [2] \"Cyclisme sur piste,Para cyclisme sur piste\"                      \n [3] \"Tennis,Tennis fauteuil,Boxe\"                                     \n [4] \"Tennis de table,Para tennis de table\"                            \n [5] \"Basketball,Basket fauteuil,Gymnastique artistique,trampoline\"    \n [6] \"Boxe,Escrime,Pentathlon moderne,Volley-ball assis\"               \n [7] \"Haltérophilie,Handball,Goalball\"                                 \n [8] \"Judo,Para judo,Lutte,Rugby fauteuil\"                             \n [9] \"Natation,Para natation,Water-polo\"                               \n[10] \"Canoë,Para canoë,Aviron,Para aviron\"                             \n[11] \"Volleyball,Boccia\"                                               \n[12] \"Volleyball de plage,Cécifoot\"                                    \n[13] \"Badminton,Para Badminton,Gymnastique rythmique,Para powerlifting\"\n[14] \"Sports équestres,Para équitation,Pentathlon moderne\"             \n[15] \"Escrime,Escrime fauteuil,Taekwondo,Para taekwondo\"               \n[16] \"Tir à l'arc,Para tir à l'arc,Athlétisme,Cyclisme sur route\"      \n\n\nIci, les sites olympiques et paralympiques accueillent différentes disciplines comme :\n- Tennis fauteil\n- Para tennis de table\n- Basket fauteil\n- Volley-ball assis\n- Para judo\n- Rugby fauteil\n- Para natation\n- Para canoe\n- Para aviron\n- Cécifoot\n- Para badminton\n- Para power liftting\n- Para equitation\n- Escrime fauteil\n- Para taekwondo\n- Para tir à l’arc\nNous aurions pu aussi créer un code qui prenait seulement les noms “para” et “fauteil” pour une utilisation plus optimal. Cependant, les disciplines cécifoot et volley-ball assis auraient surement été oublié.\n\n\n\n\n\n\n\nsites_plusieurs_sports$nb_sports \n\nIci les sites numéro 6, 7, 9, 10, 12, 15, 18 et 19 accueillent au moins 4 disciplines différentes.\n\nsites_plusieurs_sports$nom\n\nCes sites sont respectivement les suivants :\n- Arena Bercy\n- Arena Paris nord\n- Stade de la Concorde\n- Arena Champs de Mars\n- Stade nautique\n- Arena La Chapelle\n- Grand Palais\n- Invalides\n\n\n\n\n\n\n\n\n\n\ntous_les_sports &lt;- unique(unlist(data_ex$nb_sports))\n\nnb_sites_discipline &lt;- numeric(length = length(tous_les_sports))\n\nfor (i in seq_along(tous_les_sports)) {\n\n  nb_sites_discipline[i] &lt;- sum(sapply(data_ex$nb_sports, function(x) tous_les_sports[i] %in%x))\n\n  \n\n}\n\ndiscipline_max_sites &lt;-tous_les_sports[which.max(nb_sites_discipline)]\n\nsites_discipline_max &lt;-data_ex[sapply(data_ex$nb_sports, function (x) discipline_max_sites %in% x),]\n\n\ndiscipline_max_sites\n\n[1] \"Athlétisme\"\n\nsites_discipline_max$nom \n\n[1] \"Stade de France\"         \"Hôtel de ville de Paris\"\n[3] \"Pont d'Iéna\"             \"Invalides\"              \n\n\nLa discipline qui aura lieu sur le plus grand nombre de sites est l’athlétisme. Cette dernière aura lieu au Stade de France, à l’Hotel de ville de Paris, au Pont d’Iéna ainsi qu’aux Invalides.\n\n\n\n\n\n\nTout d’abord, nous divisons la colonne geo_point en deux colonnes distinctes comprennant les latitudes et longitudes de chaque sites puis nous transformons ces dernières en valeur numérique.\n\nlibrary(geosphere)\n\nlibrary(tidyverse)\n\nWarning: le package 'stringr' a été compilé avec la version R 4.3.2\n\n\n\ndata_coordonnees &lt;- data.frame(do.call('rbind', strsplit(as.character(data_ex$geo_point), ',')))\n\ncolnames(data_coordonnees) &lt;- c(\"latitude\", \"longitude\")\n\ndata_ex &lt;- cbind(data_ex, data_coordonnees)\n\nstr(data_ex)\n\ndata_ex$longitude &lt;- as.numeric(data_ex$longitude)\n\ndata_ex$latitude &lt;- as.numeric(data_ex$latitude)\n\nEnsuite, nous récupérons les données.\n\ncoordonnees &lt;- data_ex[, c(\"latitude\", \"longitude\")]\n\nPuis nous faisons la même chose avec le nom des sites.\n\nnoms_sites &lt;- data_ex$nom\n\nA présent, nous allons initialiser le nom des sites pour retrouver ceux qui sont les plus proches.\n\nsite1 &lt;- NULL\n\nsite2 &lt;- NULL\n\ndistance_min &lt;- Inf\n\nMaintenant, nous créeons une boucle afin de répondre à la question.\n\nfor (i in 1:(nrow(coordonnees) - 1)) {\n\n  for (j in (i + 1):nrow(coordonnees)) {\n\n    #Nettoyons et convertissons les noms des sites en minuscules (sinon beug)\n\n    nom_site_i &lt;- tolower(trimws(noms_sites[i]))\n\n    nom_site_j &lt;- tolower(trimws(noms_sites[j]))\n\n    \n\n    #Calculons la distance entre les sites i et j\n\n    distance &lt;- distHaversine(coordonnees[c(i, j), , drop = FALSE])\n\n    \n\n    cat(\"Distance entre\", nom_site_i, \"et\", nom_site_j, \":\", distance, \"mètres\\n\")\n\n    \n\n    #Mettons à jour les noms des sites les plus proches si la distance est plus petite entre ces couples\n\n    if (distance &lt; distance_min) {\n\n      distance_min &lt;- distance\n\n      site1 &lt;- nom_site_i\n\n      site2 &lt;- nom_site_j\n\n      \n\n      cat(\"Nouvelle paire trouvée :\", site1, \"et\", site2, \"avec distance :\", distance_min, \"mètres\\n\")\n\n    }\n\n  }\n\n}\n\nNous allons à présent afficher nos résultats.\n\nif (!is.null(site1) && !is.null(site2)) {\n\n  cat(\"Les deux sites les plus proches sont :\", site1, \"et\", site2, \"\\n\")\n\n  cat(\"La distance entre ces deux sites est :\", distance_min, \"mètres\\n\")\n\n} else {\n\n  cat(\"Aucun résultat trouvé. Vérifiez vos données.\\n\")\n\n}\n\nLes deux sites les plus proches sont : vélodrome national de saint-quentin-en-yvelines et stade bmx de saint-quentin-en-yvelines \nLa distance entre ces deux sites est : 91.69166 mètres\n\n\nLes deux sites les plus proches se trouvent à Saint-Quentin-en-Yvelines et ce sont le Vélodrome National ainsi que le Stade BMX avec une distance de 91,69 mètres.\n\n\n\n\n\n\nNous procédons de la même manière pour trouver les deux sites les plus éloignés.\n\nsite3 &lt;- NULL\n\nsite4 &lt;- NULL\n\ndistance_max &lt;- 0\n\n\nfor (x in 1:(nrow(coordonnees) - 1)) {\n\n  for (y in (x + 1):nrow(coordonnees)) {\n\n    #Nettoyons et convertissons les noms des sites en minuscules\n\n    nom_site_x &lt;- tolower(trimws(noms_sites[x]))\n\n    nom_site_y &lt;- tolower(trimws(noms_sites[y]))\n\n    \n\n    #Calculons la distance entre les sites x et y\n\n    distance &lt;- distHaversine(coordonnees[c(x, y), , drop = FALSE])\n\n    \n\n    cat(\"Distance entre\", nom_site_x, \"et\", nom_site_y, \":\", distance, \"mètres\\n\")\n\n    \n\n    #Mettons à jour les noms des sites les plus éloignés si la distance est plus grande\n\n    if (distance &gt; distance_max) {\n\n      distance_max &lt;- distance\n\n      site3 &lt;- nom_site_x\n\n      site4 &lt;- nom_site_y\n\n      \n\n      cat(\"Nouvelle paire trouvée :\", site3, \"et\", site4, \"avec distance :\", distance_max, \"mètres\\n\")\n\n    }\n\n  }\n\n}\n\n\nif (!is.null(site3) && !is.null(site4)) {\n\n  cat(\"Les deux sites les plus éloignés sont :\", site3, \"et\", site4, \"\\n\")\n\n  cat(\"La distance entre ces deux sites est :\", distance_max, \"mètres\\n\")\n\n} else {\n\n  cat(\"Aucun résultat trouvé. Vérifiez vos données.\\n\")\n\n}\n\nLes deux sites les plus éloignés sont : stade nautique et colline d'elancourt \nLa distance entre ces deux sites est : 74882.55 mètres\n\n\nIci, les deux sites les plus éloignés sont le Stade Nautique et la Colline d’Elancourt avec une distance de 74882 mètres soit 74km.\n\n\n\n\n\n\nNous allons tout d’abord calculer la moyenne des latitudes et longitudes afin de trouver le barycentre.\n\nlatitude_bary &lt;- mean(coordonnees$latitude)\n\nlongitude_bary &lt;- mean(coordonnees$longitude)\n\nA présent, nous affichons ces valeurs.\n\ncat(\"Latitude du barycentre :\", latitude_bary, \"\\n\")\n\nLatitude du barycentre : 48.86684 \n\ncat(\"Longitude du barycentre :\", longitude_bary, \"\\n\")\n\nLongitude du barycentre : 2.29757 \n\n\nLa latitude du barycentre est de 48,86684 et la longitude de 2,29757.\n\nlatitude &lt;- 48.858844\n\nlongitude &lt;- 2.294350\n\nEn faisant des recherches internet, ceci se trouve Place du Trocadéro et du 11 novembre, proche du Palais de Chaillot.\nEn effet, il fallait télécharger une clé google maps or je n’ai pas réussi à faire cela."
  },
  {
    "objectID": "posts/post-with-code/exercice 2.html",
    "href": "posts/post-with-code/exercice 2.html",
    "title": "blog",
    "section": "",
    "text": "Ce second exercice, nous a permis de travailler avec différentes base de données venant d’une liste. Ici aussi, nous avons extrait les informations principales et importantes de ces bases notamment à l’aide de la création de fonctions en manipulant des chaines des caractères.\nLa collaboration de Rodolphe Mocaër a été essentielle pour la réalisation de la majorité de cet exercice, cette contribution sera explicitement mentionnée pour chaque question où son aide a été sollicitée.\n\n\n\n\n\nlibrary(rvest)\n\nlibrary(purrr)\n\nlibrary(stringr)\n\nWarning: le package 'stringr' a été compilé avec la version R 4.3.2\n\nlibrary(tidyverse)\n\nlibrary(dplyr)\n\n\nlist_tables &lt;-\n\nsession(\"https://fr.wikipedia.org/wiki/Liste_des_m%C3%A9daill%C3%A9s_olympiques\") |&gt;\n\nhtml_elements(\".wikitable\") |&gt;\n\nhtml_table()\n\n\n\n\n\nlist_tables\n\nCette liste contient 6 tables différentes de différentes dimensions.\n\n\n\n\n\n\n\ndata_medailles_sport_ete &lt;- list_tables [[1]]\n\nprint(data_medailles_sport_ete)\n\n\n\n\n\ndata_medailles_sport_ete &lt;- data_medailles_sport_ete[,-1]\n\n\n\n\n\ndata_medailles_sport_ete &lt;- data_medailles_sport_ete[-1,]\n\n\n\n\n\ncolnames(data_medailles_sport_ete) &lt;- NULL\n\n\n\n\nc(“Discipline”, “Annees”, “Editions”,“Epreuves_2020”, “Or”, “Argent”, “Bronze”, “Total”, “Athletes_medailles”, “Athletes_or”).\n\ncolnames(data_medailles_sport_ete) &lt;- c(\"Discipline\", \"Annees\", \"Editions\",\n\n                                        \"Epreuves_2020\", \"Or\", \"Argent\", \"Bronze\", \"Total\",\n\n                                        \"Athletes_medailles\",\"Athletes_or\")\n\n\n\n\n\nstr(data_medailles_sport_ete)\n\nlibrary(dplyr)\n\ndata_medailles_sport_ete &lt;- data_medailles_sport_ete |&gt; \n\n  mutate(Editions = as.integer(Editions),\n\n         Epreuves_2020 = as.integer(Epreuves_2020),\n\n         Or = as.integer(Or),\n\n         Argent = as.integer(Argent),\n\n         Bronze = as.integer(Bronze),\n\n         Total = as.integer(Total))\n\nprint(data_medailles_sport_ete)\n\nstr(data_medailles_sport_ete)\n\n\n\n\n\n\n\n\nresultats_medailles &lt;- data_medailles_sport_ete |&gt; \n\n  group_by(Discipline) |&gt; \n\n  summarise(Total) |&gt; \n\n  arrange(desc(Total)) |&gt; \n\n  head(3)\n\nprint(resultats_medailles)\n\n# A tibble: 3 × 2\n  Discipline               Total\n  &lt;chr&gt;                    &lt;int&gt;\n1 Athlétisme                3085\n2 Natation(hommes, femmes)  1814\n3 Lutte                     1358\n\n\nLes 3 disciplines avec le plus de médailles distribuées depuis le début de l’histoire des JO sont :\\\n- L’athlétisme\n- La natation\n- La lutte\n\n\n\n\n\n\n\nmoins_epreuve_2020 &lt;- data_medailles_sport_ete |&gt; \n\n  group_by(Discipline) |&gt; \n\n  summarise(Epreuves_2020) |&gt; \n\n  arrange(Epreuves_2020) |&gt; \n\n  head(10)\n\nprint(moins_epreuve_2020)\n\n# A tibble: 10 × 2\n   Discipline            Epreuves_2020\n   &lt;chr&gt;                         &lt;int&gt;\n 1 Football                          2\n 2 Golf                              2\n 3 Handball                          2\n 4 Hockey sur gazon                  2\n 5 Natation synchronisée             2\n 6 Pentathlon moderne                2\n 7 Volley-ball                       2\n 8 Water polo                        2\n 9 Triathlon                         3\n10 Basket-ball                       4\n\n\nLes disciplines avec le moins d’épreuves en 2020 sont :\\\n- Le football\n- Le golf\n- Le handball\n- Le hockey sur gazon\n- La natation synchronisée\n- Le pentathlon moderne\n- Le volley-ball\n- Le water polo\nIl y en a donc 8.\n\n\n\n\n\n\n\n\n\n\ncalcul_nb_editions &lt;- function(depuis_annee, data_medailles_sport_ete) {\n\n \n\n   #Extrayons les années de la colonne 'Années'\n\n  data_medailles_sport_ete$Annees &lt;- as.character(data_medailles_sport_ete$Annees)\n\n  \n\n  #Utilision une expression régulière pour extraire les années de chaque cellule\n\n  data_medailles_sport_ete$Annees &lt;- gsub(\".*(\\\\d{4}).*\", \"\\\\1\", data_medailles_sport_ete$Annees)\n\n  \n\n  #Convertissons la colonne Années en numérique\n\n  data_medailles_sport_ete$Annees &lt;- as.numeric(data_medailles_sport_ete$Annees)\n\n  \n\n  #Filtrons les disciplines qui ont commencé à partir de 'depuis'\n\n  disciplines_filtrees &lt;- subset(data_medailles_sport_ete, Annees &gt;= depuis_annee)\n\n  \n\n  #Calculons le nombre total d'éditions pour chaque discipline\n\n  result &lt;- aggregate(Editions ~ Discipline, disciplines_filtrees, sum)\n\n  \n\n  return(result)\n\n}\n\n\nresultat &lt;- calcul_nb_editions(1800, data_medailles_sport_ete)\n\nprint(resultat)\n\nCela renvoit bien le bon nombre d’éditions.\n\n\n\n\n\n\n\ncalcul_nb_editions_str &lt;- function(chaine) {\n\n  # Utilisation d'une expression régulière pour extraire les années\n\n  annees &lt;- as.numeric(regmatches(chaine, gregexpr(\"\\\\b\\\\d{4}\\\\b\", chaine))[[1]])\n\n  \n\n  # Si aucune année n'est trouvée, chercher les occurrences de \"depuis\" dans la chaîne\n\n  if (length(annees) == 0) {\n\n    depuis_occurrences &lt;- gregexpr(\"\\\\bdepuis\\\\b\", chaine)\n\n    \n\n    # Si \"depuis\" est trouvé, extraire l'année après \"depuis\"\n\n    if (any(depuis_occurrences[[1]] &gt; 0)) {\n\n      annees_depuis &lt;- as.numeric(regmatches(chaine, gregexpr(\"\\\\b\\\\d{4}\\\\b\", chaine, start = depuis_occurrences[[1]][1]))[[1]])\n\n      annees &lt;- c(annees_depuis, max(annees_depuis))  # Utilisation de l'année après \"depuis\" comme début\n\n    } else {\n\n      return(0)  # Si ni année ni \"depuis\" n'est trouvé, renvoyer la valeur 0\n\n    }\n\n  }\n\n  \n\n  # Ajouter une correction pour les années manquantes (1940 et 1944)\n\n  annees_manquantes &lt;- c(1940, 1944)\n\n  annees &lt;- sort(unique(c(annees, annees_manquantes)))\n\n  \n\n  # Exclure les années sans éditions\n\n  annees &lt;- annees[!(annees %in% c(1940, 1944))]\n\n  \n\n  # Calculons le nombre d'éditions en utilisant la différence entre la première et la dernière année\n\n  nb_editions &lt;- max(annees) - min(annees) + 1\n\n  \n\n  return(nb_editions)\n\n}\n\n\nresultat &lt;- calcul_nb_editions_str(\"1896, 1904, depuis 1920\")\n\nprint(resultat)\n\n[1] 25\n\n\nIl y a 26 éditions entre 1920 et 2020 + deux éditions en 1896 et 1904 mais moins 2 éditions en 1940 et 1944 donc il faut bien que le résultat renvoie 26. Ici cela nous renvoie 25.\nAvec l’aide de Rodolphe Mocaër nous avons pu réaliser un second code afin de trouver la bonne réponse :\n\ncalcul_nb_editions_str &lt;- function(x) {\n\n  r &lt;- str_split(x, \",\", simplify = TRUE)\n\n  part &lt;- ifelse(!grepl(\"(?i)depuis|[-—–—]\", r[,]), \"1\", r[,])\n\n  return(part)\n\n}\n\n\ncalcul_nb_editions_int &lt;- function(part) {\n\n  depuis_years &lt;- str_extract_all(part, \"(?i)depuis\\\\s+(\\\\d{4})\") |&gt; \n\n    unlist() |&gt; \n\n    str_extract(\"\\\\d+\")\n\n \n\n  Calcul_edition &lt;- as.integer(depuis_years)\n\n  result &lt;- (2024 - Calcul_edition) / 4 - ifelse(Calcul_edition &lt; 1916, 3, ifelse(Calcul_edition &lt; 1944, 2, 0))\n\n \n\n  part2 &lt;- ifelse(grepl(\"(?i)depuis\\\\s+\\\\d{4}\", part), as.character(result), part)\n\n \n\n  return(part2)\n\n}\n\n\ncalcul_final &lt;- function(part2) {\n\n  part2_numerique &lt;- as.numeric(part2)\n\n  resultat_final &lt;- sum(part2_numerique)\n\n  return(resultat_final)\n\n}\n\n\ncalcul_nb_editions &lt;- function(x) {\n\n  part1 &lt;- calcul_nb_editions_str(x)\n\n  part2 &lt;- calcul_nb_editions_int(part1)\n\n  resultat_final &lt;- calcul_final(part2)\n\n  return(resultat_final)\n\n}\n\n\nresultat2 &lt;- calcul_nb_editions(\"1896, 1904, depuis 1920\")\n\nprint(resultat2)\n\n[1] 26\n\n\nIl y a bien 26 éditions.\n\nresultat3 &lt;- calcul_nb_editions_str(\"1896, 1904, depuis 1920\")\n\nprint(resultat3)\n\n[1] \"1\"            \"1\"            \" depuis 1920\"\n\n\n\n\n\n\n\n\n\n\n\ncalcul_nb_editions(2000) et calcul_nb_editions(“1904–1924, depuis 1948”)\n\ncalcul_nb_editions_str &lt;- function(x) {\n\n  r &lt;- str_split(x, \",\", simplify = TRUE)\n\n  part &lt;- ifelse(!grepl(\"(?i)depuis|[-—–—]\", r[,]), \"1\", r[,])\n\n  return(part)\n\n}\n\n\ncalcul_nb_editions_int &lt;- function(part) {\n\n  depuis_years &lt;- str_extract_all(part, \"(?i)depuis\\\\s+(\\\\d{4})\") |&gt; \n\n    unlist() |&gt; \n\n    str_extract(\"\\\\d+\")\n\n \n\n  Calcul_edition &lt;- as.integer(depuis_years)\n\n  result &lt;- (2024 - Calcul_edition) / 4 - ifelse(Calcul_edition &lt; 1916, 3, ifelse(Calcul_edition &lt; 1944, 2, 0))\n\n \n\n  part2 &lt;- ifelse(grepl(\"(?i)depuis\\\\s+\\\\d{4}\", part), as.character(result), part)\n\n \n\n  return(part2)\n\n}\n\n\ncalcul_nb_editions.character &lt;- function(part2) {\n\n  dates &lt;- str_match(part2, \"([file://\\\\d{4})\\\\s*[-—–]\\\\s*(\\\\d{4}]\\\\d{4})\\\\s*[-—–]\\\\s*(\\\\d{4})\")\n\n  a &lt;- as.integer(dates[1, 2])\n\n  b &lt;- as.integer(dates[1, 3])\n\n \n\n  x &lt;- ifelse(a &lt; 1915 & b &gt; 1917, 1,\n\n              ifelse(a &lt; 1915 & b &gt; 1945, 3,\n\n                     ifelse(1917 &lt; a & a &lt; 1939 & b &gt; 1945, 2, 0)))\n\n \n\n  c_value &lt;- (b - a) / 4 + 1 - x\n\n  part3 &lt;- ifelse(grepl(\"(\\\\d{4})\\\\s*[-—–]\\\\s*(\\\\d{4})\", part2), as.character(c_value), part2)\n\n  return(part3)\n\n}\n\n\ncalcul_final2 &lt;- function(part3) {\n\npart3_numerique &lt;- as.numeric(part3[grepl(\"^\\\\d+$\", part3)])\n\n  resultat_final &lt;- sum(part3_numerique)\n\n  return(resultat_final)\n\n}\n\n\ncalcul_nb_editions2 &lt;- function(x) {\n\n  part1 &lt;- calcul_nb_editions_str(x)\n\n  part2 &lt;- calcul_nb_editions_int(part1)\n\n  part3 &lt;- calcul_nb_editions.character(part2)\n\n  resultat_final &lt;- calcul_final2(part3)\n\n \n\n  return(resultat_final)\n\n}\n\n\nresultat3 &lt;- calcul_nb_editions(2000)\n\nprint(resultat3)\n\n[1] 1\n\n\n\nresultat4 &lt;- calcul_nb_editions(\"1904–1924, depuis 1948\")\n\nWarning in calcul_final(part2): NAs introduits lors de la conversion\nautomatique\n\nprint(resultat4)\n\n[1] NA\n\n\n\n\n\n\n\n\n\n\n\ncalcul_medailles_individuelles2 &lt;- function(data_medailles_sport_ete) {\n\n  total_medailles2 &lt;- rowSums(data_medailles_sport_ete[, c(\"Or\", \"Argent\", \"Bronze\")])\n\n  max_medailles2 &lt;- max(total_medailles2)\n\n  athletes_with_max_medals2 &lt;- data_medailles_sport_ete$Athletes_medailles[total_medailles2 == max_medailles2]\n\n  return(athletes_with_max_medals2)\n\n}\n\n\nresultat4 &lt;- calcul_medailles_individuelles2(data_medailles_sport_ete)\n\nprint(resultat4)\n\n[1] \"Paavo Nurmi (FIN) (9-3-0)\"\n\n\nLe même résultat ressort.\n\n\n\n\n\n\n\n\nall_athletes &lt;- unlist(lapply(data_medailles_sport_ete$Athletes_medailles, function(athletes) {\n\n  calcul_medailles_individuelles2(data_medailles_sport_ete[data_medailles_sport_ete$Athletes_medailles == athletes, ])\n\n}))\n\n#Nettoyons les noms des athlètes en supprimant les informations sur les médailles\n\ncleaned_athletes &lt;- gsub(\"\\\\s*\\\\(.*\\\\)\", \"\", all_athletes)\n\ntop_3_athletes &lt;- head(sort(table(cleaned_athletes), decreasing = TRUE), 3)\n\nprint(top_3_athletes)\n\ncleaned_athletes\nAna Fernández Andreï Lavrov   Ben Ainslie \n            1             1             1 \n\n\nLe top 3 des athlètes est :\n- Ana Fernandez\n- Andrei Lavrov\n- Ben Ainslie\nCependant, ce code ne semble pas fonctionner correctement. Il semble nous donner les 3 premiers athlètes par ordre alphabétique.\nAvec l’aide de Rodolphe Mocaër nous avons pu réaliser ce code.\n\ncalcul_medailles_individuelles2 &lt;- function(data_frame) {\n\n    medailles_df &lt;- data.frame(\n\n      Athlete = gsub(\"[file://\\\\s*\\\\(.*\\\\]\\\\s*\\\\(.*\\\\)\", \"\", data_frame$Athletes_medailles),\n\n      Pays = gsub(\".*\\\\((\\\\w+)\\\\)\", \"\\\\1\", data_frame$Athletes_medailles),\n\n      OR = as.integer(gsub(\".*\\\\((\\\\d+)-\\\\d+-\\\\d+\\\\)\", \"\\\\1\", data_frame$Athletes_medailles)),\n\n      ARGENT = as.integer(gsub(\".*\\\\(\\\\d+-(\\\\d+)-\\\\d+\\\\)\", \"\\\\1\", data_frame$Athletes_medailles)),\n\n      BRONZE = as.integer(gsub(\".*\\\\(\\\\d+-\\\\d+-(\\\\d+)\\\\)\", \"\\\\1\", data_frame$Athletes_medailles))\n\n    )\n\n   \n\n    medailles_df$TotalMedailles &lt;- medailles_df$OR + medailles_df$ARGENT + medailles_df$BRONZE\n\n   \n\n    classement_df &lt;- medailles_df[order(-medailles_df$TotalMedailles, -medailles_df$OR, -medailles_df$ARGENT, -medailles_df$BRONZE), ]\n\n   \n\n    meilleurs_athletes &lt;- head(classement_df$Athlete, 3)\n\n   \n\n    phrase &lt;- cat(\"Les 3 meilleurs athlètes sont:\\n\", paste(\"- \", meilleurs_athletes, collapse = \"\\n\"))\n\n   \n\n    return(phrase)\n\n  }\n\ncalcul_medailles_individuelles2(data_medailles_sport_ete)\n\nLes 3 meilleurs athlètes sont:\n -  Michael Phelp\n-  Larissa Latynina (URS) (9-5-4)\n-  Edoardo Mangiarott\n\n\nNULL\n\n\nLe top 3 des meilleurs athlètes est :\n- Michael Phelp\n- Larissa Latynina\n- Edoardo Mangiarott\n\n\n\n\n\n\n- Pour ce faire, vous implémenterez une fonction extraire_nationalite_athlete qui à partir d’une chaine de charactère extraira le nombre d’athlète et leur nationalité. Par exemple, la chaine de caractère “Paavo Nurmi (FIN) (9-3-0) Carl Lewis (USA) (9-1-0)” donnera en sortie c(“FIN” = 1, “USA” = 1).\\\n- Vous utilisez la fonction lapply pour appliquer la fonction à toute la colonne\\\n- Vous agrégerez les résultats de manière à sommer toutes les lignes et à obtenir les 3 nations les plus représentées, et leur effectif.\n\n#Fonction pour extraire la nationalité d'une chaîne de caractères\n\nextraire_nationalite_athlete &lt;- function(chaine) {\n\n  nationalites &lt;- regmatches(chaine, gregexpr(\"\\\\b[A-Z]{3}\\\\b\", chaine, perl=TRUE))[[1]]\n\n  return(nationalites)\n\n}\n\nnationalites_list &lt;- unlist(lapply(data_medailles_sport_ete$Athletes_or, extraire_nationalite_athlete))\n\ntop_3_nationalites &lt;- head(sort(table(nationalites_list), decreasing = TRUE), 3)\n\nprint(top_3_nationalites)\n\nnationalites_list\nUSA CHN CUB \n 20  13   8 \n\n\nLes 3 nations les plus représentés pour toutes les épreuves au classement du nombre de médailles d’or individuelles sont :\n- Les Etats Unis avec 20\n- La Chine avec 13\n- Cuba avec 8\n\n\n\n\n\n\n\ntable_hiver &lt;- list_tables [[2]]\n\nprint(table_hiver)\n\n\n\n\n\ntable_hiver &lt;- table_hiver[,-1]\n\n\n\n\n\ncolnames(table_hiver) = c(\"Discipline\", \"Annee\", \"Editions\", \"Epreuves_2014\", \"Or\", \"Argent\", \"Bronze\", \"Total\", \"Athletes_medailles\", \"Athletes_or\")\n\n\n\n\n\ntable_hiver &lt;- table_hiver[-1,]\n\n\nstr(table_hiver)\n\nlibrary(dplyr)\n\ntable_hiver &lt;- table_hiver |&gt; \n\n  mutate(Editions = as.integer(Editions),\n\n         Epreuves_2014 = as.integer(Epreuves_2014),\n\n         Or = as.integer(Or),\n\n         Argent = as.integer(Argent),\n\n         Bronze = as.integer(Bronze),\n\n         Total = as.integer(Total))\n\nprint(table_hiver)\n\nstr(table_hiver)\n\n\n\n\n\n\n\n\ncalcul_medailles_individuelles2_purrr &lt;- function(data_frame) {\n\n    medailles_df &lt;- data.frame(\n\n      Athlete = gsub(\"[file://\\\\s*\\\\(.*\\\\]\\\\s*\\\\(.*\\\\)\", \"\", data_frame$Athletes_medailles),\n\n      Pays = gsub(\".*\\\\((\\\\w+)\\\\)\", \"\\\\1\", data_frame$Athletes_medailles),\n\n      OR = as.integer(gsub(\".*\\\\((\\\\d+)-\\\\d+-\\\\d+\\\\)\", \"\\\\1\", data_frame$Athletes_medailles)),\n\n      ARGENT = as.integer(gsub(\".*\\\\(\\\\d+-(\\\\d+)-\\\\d+\\\\)\", \"\\\\1\", data_frame$Athletes_medailles)),\n\n      BRONZE = as.integer(gsub(\".*\\\\(\\\\d+-\\\\d+-(\\\\d+)\\\\)\", \"\\\\1\", data_frame$Athletes_medailles))\n\n    )\n\n   \n\n    medailles_df$TotalMedailles &lt;- medailles_df$OR + medailles_df$ARGENT + medailles_df$BRONZE\n\n   \n\n    classement_df &lt;- medailles_df[order(-medailles_df$TotalMedailles, -medailles_df$OR, -medailles_df$ARGENT, -medailles_df$BRONZE), ]\n\n   \n\n    meilleurs_athletes &lt;- head(classement_df$Athlete, 3)\n\n   \n\n    phrase &lt;- cat(\"Les 3 meilleurs athlètes sont :\\n\", paste(\"- \", meilleurs_athletes, collapse = \"\\n\"))\n\n   \n\n    return(phrase)\n\n}\n\ncalcul_medailles_individuelles2_purrr(table_hiver)\n\nLes 3 meilleurs athlètes sont :\n -  Marit Bjørgen (NOR) (8-4-3)\n-  Ole Einar Bjørndalen (NOR) (8-4-1)\n-  Ireen Wüst (NED) (5-5-1)\n\n\nNULL\n\n\nLes 3 meilleurs athlètes sont donc :\n- Marit Bjørgen\n- Ole Einar Bjørndalen\n- Ireen Wüst\n\nextraire_nationalite_athlete &lt;- function(chaine) {\n\n  nationalites &lt;- regmatches(chaine, gregexpr(\"\\\\b[A-Z]{3}\\\\b\", chaine, perl=TRUE))[[1]]\n\n  return(nationalites)\n\n}\n\nnationalites_list &lt;- map(table_hiver$Athletes_or, extraire_nationalite_athlete) |&gt; \n\n  flatten_chr()\n\ntop_3_nationalites &lt;- nationalites_list |&gt; \n\n  table() |&gt; \n\n  sort(decreasing = TRUE) |&gt; \n\n  head(3)\n\nprint(top_3_nationalites)\n\nnationalites_list\nCAN NOR GER \n  8   7   6 \n\n\nLes 3 nations les plus représentés pour toutes les épreuves au classement du nombre de médailles d’or individuelles sont :\n- Le Canada avec 8\n- La Norvège avec 7\n- L’Allemagne avec 6"
  },
  {
    "objectID": "posts/post-with-code/exercice 2.html#exercice-2",
    "href": "posts/post-with-code/exercice 2.html#exercice-2",
    "title": "blog",
    "section": "",
    "text": "Ce second exercice, nous a permis de travailler avec différentes base de données venant d’une liste. Ici aussi, nous avons extrait les informations principales et importantes de ces bases notamment à l’aide de la création de fonctions en manipulant des chaines des caractères.\nLa collaboration de Rodolphe Mocaër a été essentielle pour la réalisation de la majorité de cet exercice, cette contribution sera explicitement mentionnée pour chaque question où son aide a été sollicitée.\n\n\n\n\n\nlibrary(rvest)\n\nlibrary(purrr)\n\nlibrary(stringr)\n\nWarning: le package 'stringr' a été compilé avec la version R 4.3.2\n\nlibrary(tidyverse)\n\nlibrary(dplyr)\n\n\nlist_tables &lt;-\n\nsession(\"https://fr.wikipedia.org/wiki/Liste_des_m%C3%A9daill%C3%A9s_olympiques\") |&gt;\n\nhtml_elements(\".wikitable\") |&gt;\n\nhtml_table()\n\n\n\n\n\nlist_tables\n\nCette liste contient 6 tables différentes de différentes dimensions.\n\n\n\n\n\n\n\ndata_medailles_sport_ete &lt;- list_tables [[1]]\n\nprint(data_medailles_sport_ete)\n\n\n\n\n\ndata_medailles_sport_ete &lt;- data_medailles_sport_ete[,-1]\n\n\n\n\n\ndata_medailles_sport_ete &lt;- data_medailles_sport_ete[-1,]\n\n\n\n\n\ncolnames(data_medailles_sport_ete) &lt;- NULL\n\n\n\n\nc(“Discipline”, “Annees”, “Editions”,“Epreuves_2020”, “Or”, “Argent”, “Bronze”, “Total”, “Athletes_medailles”, “Athletes_or”).\n\ncolnames(data_medailles_sport_ete) &lt;- c(\"Discipline\", \"Annees\", \"Editions\",\n\n                                        \"Epreuves_2020\", \"Or\", \"Argent\", \"Bronze\", \"Total\",\n\n                                        \"Athletes_medailles\",\"Athletes_or\")\n\n\n\n\n\nstr(data_medailles_sport_ete)\n\nlibrary(dplyr)\n\ndata_medailles_sport_ete &lt;- data_medailles_sport_ete |&gt; \n\n  mutate(Editions = as.integer(Editions),\n\n         Epreuves_2020 = as.integer(Epreuves_2020),\n\n         Or = as.integer(Or),\n\n         Argent = as.integer(Argent),\n\n         Bronze = as.integer(Bronze),\n\n         Total = as.integer(Total))\n\nprint(data_medailles_sport_ete)\n\nstr(data_medailles_sport_ete)\n\n\n\n\n\n\n\n\nresultats_medailles &lt;- data_medailles_sport_ete |&gt; \n\n  group_by(Discipline) |&gt; \n\n  summarise(Total) |&gt; \n\n  arrange(desc(Total)) |&gt; \n\n  head(3)\n\nprint(resultats_medailles)\n\n# A tibble: 3 × 2\n  Discipline               Total\n  &lt;chr&gt;                    &lt;int&gt;\n1 Athlétisme                3085\n2 Natation(hommes, femmes)  1814\n3 Lutte                     1358\n\n\nLes 3 disciplines avec le plus de médailles distribuées depuis le début de l’histoire des JO sont :\\\n- L’athlétisme\n- La natation\n- La lutte\n\n\n\n\n\n\n\nmoins_epreuve_2020 &lt;- data_medailles_sport_ete |&gt; \n\n  group_by(Discipline) |&gt; \n\n  summarise(Epreuves_2020) |&gt; \n\n  arrange(Epreuves_2020) |&gt; \n\n  head(10)\n\nprint(moins_epreuve_2020)\n\n# A tibble: 10 × 2\n   Discipline            Epreuves_2020\n   &lt;chr&gt;                         &lt;int&gt;\n 1 Football                          2\n 2 Golf                              2\n 3 Handball                          2\n 4 Hockey sur gazon                  2\n 5 Natation synchronisée             2\n 6 Pentathlon moderne                2\n 7 Volley-ball                       2\n 8 Water polo                        2\n 9 Triathlon                         3\n10 Basket-ball                       4\n\n\nLes disciplines avec le moins d’épreuves en 2020 sont :\\\n- Le football\n- Le golf\n- Le handball\n- Le hockey sur gazon\n- La natation synchronisée\n- Le pentathlon moderne\n- Le volley-ball\n- Le water polo\nIl y en a donc 8.\n\n\n\n\n\n\n\n\n\n\ncalcul_nb_editions &lt;- function(depuis_annee, data_medailles_sport_ete) {\n\n \n\n   #Extrayons les années de la colonne 'Années'\n\n  data_medailles_sport_ete$Annees &lt;- as.character(data_medailles_sport_ete$Annees)\n\n  \n\n  #Utilision une expression régulière pour extraire les années de chaque cellule\n\n  data_medailles_sport_ete$Annees &lt;- gsub(\".*(\\\\d{4}).*\", \"\\\\1\", data_medailles_sport_ete$Annees)\n\n  \n\n  #Convertissons la colonne Années en numérique\n\n  data_medailles_sport_ete$Annees &lt;- as.numeric(data_medailles_sport_ete$Annees)\n\n  \n\n  #Filtrons les disciplines qui ont commencé à partir de 'depuis'\n\n  disciplines_filtrees &lt;- subset(data_medailles_sport_ete, Annees &gt;= depuis_annee)\n\n  \n\n  #Calculons le nombre total d'éditions pour chaque discipline\n\n  result &lt;- aggregate(Editions ~ Discipline, disciplines_filtrees, sum)\n\n  \n\n  return(result)\n\n}\n\n\nresultat &lt;- calcul_nb_editions(1800, data_medailles_sport_ete)\n\nprint(resultat)\n\nCela renvoit bien le bon nombre d’éditions.\n\n\n\n\n\n\n\ncalcul_nb_editions_str &lt;- function(chaine) {\n\n  # Utilisation d'une expression régulière pour extraire les années\n\n  annees &lt;- as.numeric(regmatches(chaine, gregexpr(\"\\\\b\\\\d{4}\\\\b\", chaine))[[1]])\n\n  \n\n  # Si aucune année n'est trouvée, chercher les occurrences de \"depuis\" dans la chaîne\n\n  if (length(annees) == 0) {\n\n    depuis_occurrences &lt;- gregexpr(\"\\\\bdepuis\\\\b\", chaine)\n\n    \n\n    # Si \"depuis\" est trouvé, extraire l'année après \"depuis\"\n\n    if (any(depuis_occurrences[[1]] &gt; 0)) {\n\n      annees_depuis &lt;- as.numeric(regmatches(chaine, gregexpr(\"\\\\b\\\\d{4}\\\\b\", chaine, start = depuis_occurrences[[1]][1]))[[1]])\n\n      annees &lt;- c(annees_depuis, max(annees_depuis))  # Utilisation de l'année après \"depuis\" comme début\n\n    } else {\n\n      return(0)  # Si ni année ni \"depuis\" n'est trouvé, renvoyer la valeur 0\n\n    }\n\n  }\n\n  \n\n  # Ajouter une correction pour les années manquantes (1940 et 1944)\n\n  annees_manquantes &lt;- c(1940, 1944)\n\n  annees &lt;- sort(unique(c(annees, annees_manquantes)))\n\n  \n\n  # Exclure les années sans éditions\n\n  annees &lt;- annees[!(annees %in% c(1940, 1944))]\n\n  \n\n  # Calculons le nombre d'éditions en utilisant la différence entre la première et la dernière année\n\n  nb_editions &lt;- max(annees) - min(annees) + 1\n\n  \n\n  return(nb_editions)\n\n}\n\n\nresultat &lt;- calcul_nb_editions_str(\"1896, 1904, depuis 1920\")\n\nprint(resultat)\n\n[1] 25\n\n\nIl y a 26 éditions entre 1920 et 2020 + deux éditions en 1896 et 1904 mais moins 2 éditions en 1940 et 1944 donc il faut bien que le résultat renvoie 26. Ici cela nous renvoie 25.\nAvec l’aide de Rodolphe Mocaër nous avons pu réaliser un second code afin de trouver la bonne réponse :\n\ncalcul_nb_editions_str &lt;- function(x) {\n\n  r &lt;- str_split(x, \",\", simplify = TRUE)\n\n  part &lt;- ifelse(!grepl(\"(?i)depuis|[-—–—]\", r[,]), \"1\", r[,])\n\n  return(part)\n\n}\n\n\ncalcul_nb_editions_int &lt;- function(part) {\n\n  depuis_years &lt;- str_extract_all(part, \"(?i)depuis\\\\s+(\\\\d{4})\") |&gt; \n\n    unlist() |&gt; \n\n    str_extract(\"\\\\d+\")\n\n \n\n  Calcul_edition &lt;- as.integer(depuis_years)\n\n  result &lt;- (2024 - Calcul_edition) / 4 - ifelse(Calcul_edition &lt; 1916, 3, ifelse(Calcul_edition &lt; 1944, 2, 0))\n\n \n\n  part2 &lt;- ifelse(grepl(\"(?i)depuis\\\\s+\\\\d{4}\", part), as.character(result), part)\n\n \n\n  return(part2)\n\n}\n\n\ncalcul_final &lt;- function(part2) {\n\n  part2_numerique &lt;- as.numeric(part2)\n\n  resultat_final &lt;- sum(part2_numerique)\n\n  return(resultat_final)\n\n}\n\n\ncalcul_nb_editions &lt;- function(x) {\n\n  part1 &lt;- calcul_nb_editions_str(x)\n\n  part2 &lt;- calcul_nb_editions_int(part1)\n\n  resultat_final &lt;- calcul_final(part2)\n\n  return(resultat_final)\n\n}\n\n\nresultat2 &lt;- calcul_nb_editions(\"1896, 1904, depuis 1920\")\n\nprint(resultat2)\n\n[1] 26\n\n\nIl y a bien 26 éditions.\n\nresultat3 &lt;- calcul_nb_editions_str(\"1896, 1904, depuis 1920\")\n\nprint(resultat3)\n\n[1] \"1\"            \"1\"            \" depuis 1920\"\n\n\n\n\n\n\n\n\n\n\n\ncalcul_nb_editions(2000) et calcul_nb_editions(“1904–1924, depuis 1948”)\n\ncalcul_nb_editions_str &lt;- function(x) {\n\n  r &lt;- str_split(x, \",\", simplify = TRUE)\n\n  part &lt;- ifelse(!grepl(\"(?i)depuis|[-—–—]\", r[,]), \"1\", r[,])\n\n  return(part)\n\n}\n\n\ncalcul_nb_editions_int &lt;- function(part) {\n\n  depuis_years &lt;- str_extract_all(part, \"(?i)depuis\\\\s+(\\\\d{4})\") |&gt; \n\n    unlist() |&gt; \n\n    str_extract(\"\\\\d+\")\n\n \n\n  Calcul_edition &lt;- as.integer(depuis_years)\n\n  result &lt;- (2024 - Calcul_edition) / 4 - ifelse(Calcul_edition &lt; 1916, 3, ifelse(Calcul_edition &lt; 1944, 2, 0))\n\n \n\n  part2 &lt;- ifelse(grepl(\"(?i)depuis\\\\s+\\\\d{4}\", part), as.character(result), part)\n\n \n\n  return(part2)\n\n}\n\n\ncalcul_nb_editions.character &lt;- function(part2) {\n\n  dates &lt;- str_match(part2, \"([file://\\\\d{4})\\\\s*[-—–]\\\\s*(\\\\d{4}]\\\\d{4})\\\\s*[-—–]\\\\s*(\\\\d{4})\")\n\n  a &lt;- as.integer(dates[1, 2])\n\n  b &lt;- as.integer(dates[1, 3])\n\n \n\n  x &lt;- ifelse(a &lt; 1915 & b &gt; 1917, 1,\n\n              ifelse(a &lt; 1915 & b &gt; 1945, 3,\n\n                     ifelse(1917 &lt; a & a &lt; 1939 & b &gt; 1945, 2, 0)))\n\n \n\n  c_value &lt;- (b - a) / 4 + 1 - x\n\n  part3 &lt;- ifelse(grepl(\"(\\\\d{4})\\\\s*[-—–]\\\\s*(\\\\d{4})\", part2), as.character(c_value), part2)\n\n  return(part3)\n\n}\n\n\ncalcul_final2 &lt;- function(part3) {\n\npart3_numerique &lt;- as.numeric(part3[grepl(\"^\\\\d+$\", part3)])\n\n  resultat_final &lt;- sum(part3_numerique)\n\n  return(resultat_final)\n\n}\n\n\ncalcul_nb_editions2 &lt;- function(x) {\n\n  part1 &lt;- calcul_nb_editions_str(x)\n\n  part2 &lt;- calcul_nb_editions_int(part1)\n\n  part3 &lt;- calcul_nb_editions.character(part2)\n\n  resultat_final &lt;- calcul_final2(part3)\n\n \n\n  return(resultat_final)\n\n}\n\n\nresultat3 &lt;- calcul_nb_editions(2000)\n\nprint(resultat3)\n\n[1] 1\n\n\n\nresultat4 &lt;- calcul_nb_editions(\"1904–1924, depuis 1948\")\n\nWarning in calcul_final(part2): NAs introduits lors de la conversion\nautomatique\n\nprint(resultat4)\n\n[1] NA\n\n\n\n\n\n\n\n\n\n\n\ncalcul_medailles_individuelles2 &lt;- function(data_medailles_sport_ete) {\n\n  total_medailles2 &lt;- rowSums(data_medailles_sport_ete[, c(\"Or\", \"Argent\", \"Bronze\")])\n\n  max_medailles2 &lt;- max(total_medailles2)\n\n  athletes_with_max_medals2 &lt;- data_medailles_sport_ete$Athletes_medailles[total_medailles2 == max_medailles2]\n\n  return(athletes_with_max_medals2)\n\n}\n\n\nresultat4 &lt;- calcul_medailles_individuelles2(data_medailles_sport_ete)\n\nprint(resultat4)\n\n[1] \"Paavo Nurmi (FIN) (9-3-0)\"\n\n\nLe même résultat ressort.\n\n\n\n\n\n\n\n\nall_athletes &lt;- unlist(lapply(data_medailles_sport_ete$Athletes_medailles, function(athletes) {\n\n  calcul_medailles_individuelles2(data_medailles_sport_ete[data_medailles_sport_ete$Athletes_medailles == athletes, ])\n\n}))\n\n#Nettoyons les noms des athlètes en supprimant les informations sur les médailles\n\ncleaned_athletes &lt;- gsub(\"\\\\s*\\\\(.*\\\\)\", \"\", all_athletes)\n\ntop_3_athletes &lt;- head(sort(table(cleaned_athletes), decreasing = TRUE), 3)\n\nprint(top_3_athletes)\n\ncleaned_athletes\nAna Fernández Andreï Lavrov   Ben Ainslie \n            1             1             1 \n\n\nLe top 3 des athlètes est :\n- Ana Fernandez\n- Andrei Lavrov\n- Ben Ainslie\nCependant, ce code ne semble pas fonctionner correctement. Il semble nous donner les 3 premiers athlètes par ordre alphabétique.\nAvec l’aide de Rodolphe Mocaër nous avons pu réaliser ce code.\n\ncalcul_medailles_individuelles2 &lt;- function(data_frame) {\n\n    medailles_df &lt;- data.frame(\n\n      Athlete = gsub(\"[file://\\\\s*\\\\(.*\\\\]\\\\s*\\\\(.*\\\\)\", \"\", data_frame$Athletes_medailles),\n\n      Pays = gsub(\".*\\\\((\\\\w+)\\\\)\", \"\\\\1\", data_frame$Athletes_medailles),\n\n      OR = as.integer(gsub(\".*\\\\((\\\\d+)-\\\\d+-\\\\d+\\\\)\", \"\\\\1\", data_frame$Athletes_medailles)),\n\n      ARGENT = as.integer(gsub(\".*\\\\(\\\\d+-(\\\\d+)-\\\\d+\\\\)\", \"\\\\1\", data_frame$Athletes_medailles)),\n\n      BRONZE = as.integer(gsub(\".*\\\\(\\\\d+-\\\\d+-(\\\\d+)\\\\)\", \"\\\\1\", data_frame$Athletes_medailles))\n\n    )\n\n   \n\n    medailles_df$TotalMedailles &lt;- medailles_df$OR + medailles_df$ARGENT + medailles_df$BRONZE\n\n   \n\n    classement_df &lt;- medailles_df[order(-medailles_df$TotalMedailles, -medailles_df$OR, -medailles_df$ARGENT, -medailles_df$BRONZE), ]\n\n   \n\n    meilleurs_athletes &lt;- head(classement_df$Athlete, 3)\n\n   \n\n    phrase &lt;- cat(\"Les 3 meilleurs athlètes sont:\\n\", paste(\"- \", meilleurs_athletes, collapse = \"\\n\"))\n\n   \n\n    return(phrase)\n\n  }\n\ncalcul_medailles_individuelles2(data_medailles_sport_ete)\n\nLes 3 meilleurs athlètes sont:\n -  Michael Phelp\n-  Larissa Latynina (URS) (9-5-4)\n-  Edoardo Mangiarott\n\n\nNULL\n\n\nLe top 3 des meilleurs athlètes est :\n- Michael Phelp\n- Larissa Latynina\n- Edoardo Mangiarott\n\n\n\n\n\n\n- Pour ce faire, vous implémenterez une fonction extraire_nationalite_athlete qui à partir d’une chaine de charactère extraira le nombre d’athlète et leur nationalité. Par exemple, la chaine de caractère “Paavo Nurmi (FIN) (9-3-0) Carl Lewis (USA) (9-1-0)” donnera en sortie c(“FIN” = 1, “USA” = 1).\\\n- Vous utilisez la fonction lapply pour appliquer la fonction à toute la colonne\\\n- Vous agrégerez les résultats de manière à sommer toutes les lignes et à obtenir les 3 nations les plus représentées, et leur effectif.\n\n#Fonction pour extraire la nationalité d'une chaîne de caractères\n\nextraire_nationalite_athlete &lt;- function(chaine) {\n\n  nationalites &lt;- regmatches(chaine, gregexpr(\"\\\\b[A-Z]{3}\\\\b\", chaine, perl=TRUE))[[1]]\n\n  return(nationalites)\n\n}\n\nnationalites_list &lt;- unlist(lapply(data_medailles_sport_ete$Athletes_or, extraire_nationalite_athlete))\n\ntop_3_nationalites &lt;- head(sort(table(nationalites_list), decreasing = TRUE), 3)\n\nprint(top_3_nationalites)\n\nnationalites_list\nUSA CHN CUB \n 20  13   8 \n\n\nLes 3 nations les plus représentés pour toutes les épreuves au classement du nombre de médailles d’or individuelles sont :\n- Les Etats Unis avec 20\n- La Chine avec 13\n- Cuba avec 8\n\n\n\n\n\n\n\ntable_hiver &lt;- list_tables [[2]]\n\nprint(table_hiver)\n\n\n\n\n\ntable_hiver &lt;- table_hiver[,-1]\n\n\n\n\n\ncolnames(table_hiver) = c(\"Discipline\", \"Annee\", \"Editions\", \"Epreuves_2014\", \"Or\", \"Argent\", \"Bronze\", \"Total\", \"Athletes_medailles\", \"Athletes_or\")\n\n\n\n\n\ntable_hiver &lt;- table_hiver[-1,]\n\n\nstr(table_hiver)\n\nlibrary(dplyr)\n\ntable_hiver &lt;- table_hiver |&gt; \n\n  mutate(Editions = as.integer(Editions),\n\n         Epreuves_2014 = as.integer(Epreuves_2014),\n\n         Or = as.integer(Or),\n\n         Argent = as.integer(Argent),\n\n         Bronze = as.integer(Bronze),\n\n         Total = as.integer(Total))\n\nprint(table_hiver)\n\nstr(table_hiver)\n\n\n\n\n\n\n\n\ncalcul_medailles_individuelles2_purrr &lt;- function(data_frame) {\n\n    medailles_df &lt;- data.frame(\n\n      Athlete = gsub(\"[file://\\\\s*\\\\(.*\\\\]\\\\s*\\\\(.*\\\\)\", \"\", data_frame$Athletes_medailles),\n\n      Pays = gsub(\".*\\\\((\\\\w+)\\\\)\", \"\\\\1\", data_frame$Athletes_medailles),\n\n      OR = as.integer(gsub(\".*\\\\((\\\\d+)-\\\\d+-\\\\d+\\\\)\", \"\\\\1\", data_frame$Athletes_medailles)),\n\n      ARGENT = as.integer(gsub(\".*\\\\(\\\\d+-(\\\\d+)-\\\\d+\\\\)\", \"\\\\1\", data_frame$Athletes_medailles)),\n\n      BRONZE = as.integer(gsub(\".*\\\\(\\\\d+-\\\\d+-(\\\\d+)\\\\)\", \"\\\\1\", data_frame$Athletes_medailles))\n\n    )\n\n   \n\n    medailles_df$TotalMedailles &lt;- medailles_df$OR + medailles_df$ARGENT + medailles_df$BRONZE\n\n   \n\n    classement_df &lt;- medailles_df[order(-medailles_df$TotalMedailles, -medailles_df$OR, -medailles_df$ARGENT, -medailles_df$BRONZE), ]\n\n   \n\n    meilleurs_athletes &lt;- head(classement_df$Athlete, 3)\n\n   \n\n    phrase &lt;- cat(\"Les 3 meilleurs athlètes sont :\\n\", paste(\"- \", meilleurs_athletes, collapse = \"\\n\"))\n\n   \n\n    return(phrase)\n\n}\n\ncalcul_medailles_individuelles2_purrr(table_hiver)\n\nLes 3 meilleurs athlètes sont :\n -  Marit Bjørgen (NOR) (8-4-3)\n-  Ole Einar Bjørndalen (NOR) (8-4-1)\n-  Ireen Wüst (NED) (5-5-1)\n\n\nNULL\n\n\nLes 3 meilleurs athlètes sont donc :\n- Marit Bjørgen\n- Ole Einar Bjørndalen\n- Ireen Wüst\n\nextraire_nationalite_athlete &lt;- function(chaine) {\n\n  nationalites &lt;- regmatches(chaine, gregexpr(\"\\\\b[A-Z]{3}\\\\b\", chaine, perl=TRUE))[[1]]\n\n  return(nationalites)\n\n}\n\nnationalites_list &lt;- map(table_hiver$Athletes_or, extraire_nationalite_athlete) |&gt; \n\n  flatten_chr()\n\ntop_3_nationalites &lt;- nationalites_list |&gt; \n\n  table() |&gt; \n\n  sort(decreasing = TRUE) |&gt; \n\n  head(3)\n\nprint(top_3_nationalites)\n\nnationalites_list\nCAN NOR GER \n  8   7   6 \n\n\nLes 3 nations les plus représentés pour toutes les épreuves au classement du nombre de médailles d’or individuelles sont :\n- Le Canada avec 8\n- La Norvège avec 7\n- L’Allemagne avec 6"
  },
  {
    "objectID": "posts/post-with-code/exercice 3.html",
    "href": "posts/post-with-code/exercice 3.html",
    "title": "blog",
    "section": "",
    "text": "Ce dernier exercice nous a permis d’utiliser des bases de données différentes notamment json, parquet et sqlite. Nous avons, ici aussi, nettoyer et visualiser les différentes bases. Nous avons également utiliser le package lubridate afin de traiter des dates.\n\n\n\nlibrary(stringr)\n\nWarning: le package 'stringr' a été compilé avec la version R 4.3.2\n\nlibrary(lubridate)\nlibrary(arrow)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(jsonlite)\n\nWarning: le package 'jsonlite' a été compilé avec la version R 4.3.2\n\nlibrary(RSQLite)\n\n\n\n\n\n\n\ndata &lt;- list.files(\"data\")\n\nprint(data)\n\ncharacter(0)\n\nextensions &lt;- tools::file_ext(data)\n\nprint(extensions)\n\nlogical(0)\n\n\nIl y a 4 fichiers dans le dossier data dont un sous format sqlite, un autre json et enfin parquet.\n\n\n\n\n\n\n\ntokyo &lt;- read_parquet(\"C:/Users/mathi/OneDrive/Documents/M1 ECAP/Semestre 2/R avancé et Git/TD3/tokyo_athletes.parquet\")\n\ndim(tokyo)\n\n[1] 11085     3\n\n\nLa table tokyo comprend 11 085 lignes et 3 colonnes.\n\nsummary(tokyo)\n\n     Name               NOC             Discipline       \n Length:11085       Length:11085       Length:11085      \n Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character  \n\n\nLes 3 colonnes se nomment :\n- Name\n- NOC\n- Discipline\n\n\n\n\n\n\n\nolympics &lt;-read_json(\"C:/Users/mathi/OneDrive/Documents/M1 ECAP/Semestre 2/R avancé et Git/TD3/olympics_athletes.json\")\n\ndim(olympics)\n\nstr(olympics)\n\nIl y a 12 colonnes :\n- ID\n- Name\n- Sex\n- Age\n- Height\n- Weight\n- Team\n- NOC\n- Games\n- City\n- Sport\n- Event\n\n\n\n\n\n\n\nconnexion &lt;- dbConnect(drv=RSQLite::SQLite(), dbname=\"C:/Users/mathi/OneDrive/Documents/M1 ECAP/Semestre 2/R avancé et Git/TD3/data.sqlite\")\n\ntables &lt;- dbListTables(connexion)\n\ntables\n\n[1] \"olympics_athletes\" \"tokyo_athletes\"    \"tokyo_medals\"     \n[4] \"tokyo_teams\"      \n\n\nIci, cela contient :\n- olympics_athletes\n- tokyo_athletes\n- tokyo_medals\n- tokyo_teams\n\n\n\n\n\n\n\nif (dbIsValid(connexion)) {\n\n  \n\n  file_olympics &lt;- \"olympics_athletes.json\"\n\n  file_tokyo &lt;- \"tokyo_athletes.parquet\"\n\n  \n\n  tryCatch({\n\n    # Chargeons les données json avec read_json\n\n    data_olympics &lt;- read_json(file_olympics, simplifyVector = TRUE)\n\n    \n\n    #Convertissons les données en data.frame \n\n   \n\n   data_olympics_df &lt;- as.data.frame(data_olympics)\n\n    \n\n    # Utilisation dbWriteTable avec append=TRUE pour ajouter à la table déjà existante\n\n  dbWriteTable(connexion, \"olympics_athletes\", data_olympics_df, append = TRUE)\n\n    \n\n    # Utilisation dbWriteTable avec overwrite=TRUE pour écraser la table existante (sinon beug)\n\n  dbWriteTable(connexion, \"tokyo_athletes\", read_parquet(file_tokyo), overwrite = TRUE)\n\n  }, error = function(e) {\n\n    cat(\"Erreur lors de la lecture du fichier JSON :\", conditionMessage(e), \"\\n\")\n\n  })\n\n  \n\n  # Ne pas fermer la connexion ici \n\n} else {\n\n  cat(\"Erreur: La connexion à la base de données a échoué.\")\n\n}\n\n\n\n\n\n\n\n\nif (dbIsValid(connexion)) {\n\n  colonnes_olympics &lt;- dbListFields(connexion, \"olympics_athletes\")\n\n  print(colonnes_olympics)\n\n} else {\n\n  cat(\"Erreur: La connexion à la base de données a échoué.\")\n\n}\n\n [1] \"ID\"     \"Name\"   \"Sex\"    \"Age\"    \"Height\" \"Weight\" \"Team\"   \"NOC\"   \n [9] \"Games\"  \"City\"   \"Sport\"  \"Event\"  \"Medal\" \n\n\nLes colonnes sont les suivantes :\n- ID\n- Name\n- Sex\n- Age\n- Height\n- Weight\n- Team\n- NOC\n- Games\n- City\n- Sport\n- Event\n- Medal\n\n\n\n\n\n\nConvertissez la table en tibble en utilisant la fonction as_tibble.\n\nif (dbIsValid(connexion)) {\n\n  \n\n  nom_table &lt;- \"olympics_athletes\"\n\n  \n\n  #Importation la table depuis la base de données\n\n  table_importee &lt;- dbReadTable(connexion, nom_table)\n\n  \n\n  #Convertissons la table en tibble\n\n  tibble_resultat &lt;- as_tibble(table_importee)\n\n  \n\n  print(tibble_resultat)\n\n  \n\n} else {\n\n  cat(\"Erreur: La connexion à la base de données a échoué.\")\n\n}\n\n# A tibble: 1,078,924 × 13\n      ID Name      Sex     Age Height Weight Team  NOC   Games City  Sport Event\n   &lt;int&gt; &lt;chr&gt;     &lt;chr&gt; &lt;int&gt;  &lt;int&gt;  &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n 1     1 A Dijiang M        24    180     80 China CHN   1992… Barc… Bask… Bask…\n 2     2 A Lamusi  M        23    170     60 China CHN   2012… Lond… Judo  Judo…\n 3     3 Gunnar N… M        24     NA     NA Denm… DEN   1920… Antw… Foot… Foot…\n 4     4 Edgar Li… M        34     NA     NA Denm… DEN   1900… Paris Tug-… Tug-…\n 5     5 Christin… F        21    185     82 Neth… NED   1988… Calg… Spee… Spee…\n 6     5 Christin… F        21    185     82 Neth… NED   1988… Calg… Spee… Spee…\n 7     5 Christin… F        25    185     82 Neth… NED   1992… Albe… Spee… Spee…\n 8     5 Christin… F        25    185     82 Neth… NED   1992… Albe… Spee… Spee…\n 9     5 Christin… F        27    185     82 Neth… NED   1994… Lill… Spee… Spee…\n10     5 Christin… F        27    185     82 Neth… NED   1994… Lill… Spee… Spee…\n# ℹ 1,078,914 more rows\n# ℹ 1 more variable: Medal &lt;chr&gt;\n\n\n\n\n\n\n\n\n\n\n\n\ntibble_resultat &lt;- tibble_resultat|&gt; \n\n  mutate(Sex = as.factor(Sex))\n\nprint(tibble_resultat)\n\n\n\n\n\n\n\n\ntibble_resultat &lt;- tibble_resultat |&gt; \n\n  separate(Games, into = c(\"Year\", \"isSummer\"), sep = \" \", convert = TRUE)\n\n\nprint(tibble_resultat)\n\ntibble_resultat\n\n\n\n\n\n\n\n\n\n\n\nresultats_moyenne_age &lt;- tibble_resultat |&gt; \n\n  group_by(Year) |&gt; \n\n  summarise(moyenne_age = mean(Age, na.rm = TRUE))\n\n#Identification de l'édition avec les athlètes les plus jeunes\n\nplus_jeunes &lt;- resultats_moyenne_age |&gt; \n\n  filter(moyenne_age == min(moyenne_age, na.rm = TRUE))\n\n# Identification de l'édition avec les athlètes les plus vieux\n\nplus_vieux &lt;- resultats_moyenne_age |&gt;  \n\n  filter(moyenne_age == max(moyenne_age, na.rm = TRUE))\n\n\nprint(resultats_moyenne_age)\n\n# A tibble: 35 × 2\n    Year moyenne_age\n   &lt;int&gt;       &lt;dbl&gt;\n 1  1896        23.6\n 2  1900        28.9\n 3  1904        26.7\n 4  1906        27.1\n 5  1908        27.0\n 6  1912        27.5\n 7  1920        29.3\n 8  1924        28.0\n 9  1928        27.9\n10  1932        29.6\n# ℹ 25 more rows\n\n\n\nprint(plus_jeunes)\n\n# A tibble: 1 × 2\n   Year moyenne_age\n  &lt;int&gt;       &lt;dbl&gt;\n1  1896        23.6\n\n\nL’édition avec les athlètes les plus jeunes était en 1896 et la moyenne d’âge était de 23,6 ans\n\nprint(plus_vieux)\n\n# A tibble: 1 × 2\n   Year moyenne_age\n  &lt;int&gt;       &lt;dbl&gt;\n1  1932        29.6\n\n\nL’édition avec les athlètes les plus vieux était en 1932 et la moyenne d’âge était de 29,6 ans\n\n\n\n\n\n\n\nathletes_femmes &lt;- tibble_resultat |&gt; \n\n  filter(Sex == \"F\")\n\n#Remplacons les valeurs manquantes de Height par une valeur spécifique ici 0 pour simplifier\n\nathletes_femmes &lt;- athletes_femmes |&gt; \n\n  mutate(Height = ifelse(is.na(Height), 0, Height))\n\n#Regroupeons par discipline et par année, puis calculons la taille maximale des athlètes féminines\n\nplus_grande_taille_par_discipline &lt;- athletes_femmes |&gt; \n\n  group_by(Sport, Year, .groups = \"drop_last\") |&gt; \n\n  summarise(taille_max = max(Height, na.rm = TRUE), .groups = \"drop_last\")\n\n#Identification de la discipline avec la plus grande taille pour chaque année\n\nplus_grande_taille_discipline_par_annee &lt;- plus_grande_taille_par_discipline |&gt; \n\n  group_by(Year, .groups = \"drop_last\") |&gt; \n\n  filter(taille_max == max(taille_max, na.rm = TRUE), .groups == \"drop_last\")\n\n#Identification de la discipline qui a été la plus grande (en fonction de la fréquence)\n\ndiscipline_plus_grande_frequence &lt;- plus_grande_taille_discipline_par_annee |&gt; \n\n  group_by(Sport, .groups = \"drop_last\") |&gt; \n\n  summarise(frequence = n(), .groups = \"drop_last\")\n\n\nprint(\"Discipline des JO d'été avec la plus grande taille d'athlètes féminines par année :\")\n\nprint(plus_grande_taille_discipline_par_annee, n = 60)\n\nLa plus grande taille par discipline provient du Basketball avec 213cm\n\nprint(\"Discipline avec la plus grande taille d'athlètes féminines le plus souvent :\")\n\n[1] \"Discipline avec la plus grande taille d'athlètes féminines le plus souvent :\"\n\nprint(discipline_plus_grande_frequence, n = 60)\n\n# A tibble: 17 × 3\n# Groups:   Sport [17]\n   Sport          .groups   frequence\n   &lt;chr&gt;          &lt;chr&gt;         &lt;int&gt;\n 1 Archery        drop_last         2\n 2 Athletics      drop_last         6\n 3 Basketball     drop_last        11\n 4 Bobsleigh      drop_last         3\n 5 Croquet        drop_last         1\n 6 Diving         drop_last         2\n 7 Equestrianism  drop_last         1\n 8 Fencing        drop_last         4\n 9 Figure Skating drop_last         1\n10 Golf           drop_last         1\n11 Ice Hockey     drop_last         1\n12 Luge           drop_last         2\n13 Motorboating   drop_last         1\n14 Sailing        drop_last         2\n15 Swimming       drop_last         2\n16 Tennis         drop_last         5\n17 Volleyball     drop_last         3\n\n\nTout cela pour une frequence de 11.\n\n\n\n\n\ntexte &lt;- \"Les jeux olympiques d'été se déroulent normalement tous \n\nles 4 ans, durant les mois de Juillet et Août. \n\nLes jeux de Rio ont eu lieu du 5 Août 2016 au 20 Août 2016, \n\nceux de Tokyo du 23 Juillet 2021 au 8 Août 2021, \n\net ceux de Paris auront lieu du 26 Juillet 2024 au 11 Août 2024. \n\nPlus de 10000 athlètes sont attendus du monde entier à Paris.\"\n\n\n\n\n\n\n\n\n\n\n#Expression régulière pour capturer une date au format \"jour Mois année\"\n\nregex_date &lt;- \"\\\\b\\\\d{1,2} (Janvier|Février|Mars|Avril|Mai|Juin|Juillet|Août|Septembre|Octobre|Novembre|Décembre) \\\\d{4}\\\\b\"\n\n#Utilisaton str_extract_all pour extraire toutes les dates du texte\n\ndates &lt;- str_extract_all(texte, regex_date)[[1]]\n\nprint(dates)\n\n[1] \"5 Août 2016\"     \"20 Août 2016\"    \"23 Juillet 2021\" \"8 Août 2021\"    \n[5] \"26 Juillet 2024\" \"11 Août 2024\"   \n\n\n\n\n\n\n\n\n\nmois_en_numero &lt;- function(mois) {\n\n  mois &lt;- tolower(mois)\n\n  mois_numeros &lt;- c(\"janvier\", \"février\", \"mars\", \"avril\", \"mai\", \"juin\", \"juillet\", \"août\", \"septembre\", \"octobre\", \"novembre\", \"décembre\")\n\n  return(match(mois, mois_numeros))\n\n}\n\n#Remplaceons les noms des mois par leur numéro\n\ndates_numerotees &lt;- str_replace_all(dates, regex_date, function(match) {\n\n  elements &lt;- str_split(match, \" \")[[1]]\n\n  elements[2] &lt;- mois_en_numero(elements[2])\n\n  return(paste(elements, collapse = \" \"))\n\n})\n\nprint(dates_numerotees)\n\n[1] \"5 8 2016\"  \"20 8 2016\" \"23 7 2021\" \"8 8 2021\"  \"26 7 2024\" \"11 8 2024\"\n\n\n\n\n\n\n\n\n\nconvertir_en_date &lt;- function(date_texte) {\n\n  elements &lt;- str_split(date_texte, \" \")[[1]]\n\n  jour &lt;- as.integer(elements[1])\n\n  mois &lt;- as.integer(elements[2])\n\n  annee &lt;- as.integer(elements[3])\n\n  return(dmy(paste(jour, mois, annee, sep = \"-\")))\n\n}\n\n#Appliqueons la fonction à chaque élément de la liste\n\ndates_converties &lt;- sapply(dates_numerotees, convertir_en_date)\n\nprint(dates_converties)\n\n 5 8 2016 20 8 2016 23 7 2021  8 8 2021 26 7 2024 11 8 2024 \n    17018     17033     18831     18847     19930     19946 \n\n\n\n\n\n\n\n\n\n\n\n\nrio_date &lt;- dmy(\"5 Août 2016\")\n\ntokyo_date &lt;- dmy(\"23 Juillet 2021\")\n\nparis_date &lt;- dmy(\"26 Juillet 2024\")\n\n\njours_entre_rio_et_tokyo &lt;- as.numeric(difftime(tokyo_date, rio_date, units = \"days\"))\n\ncat(\"Nombre de jours entre Rio et Tokyo :\", jours_entre_rio_et_tokyo, \"jours\\n\")\n\nNombre de jours entre Rio et Tokyo : 1813 jours\n\n\nIl y a 1 813 jours entre les éditions de Rio en 2016 et de Tokyo en 2021\n\njours_entre_tokyo_et_paris &lt;- as.numeric(difftime(paris_date, tokyo_date, units = \"days\"))\n\ncat(\"Nombre de jours entre Tokyo et Paris :\", jours_entre_tokyo_et_paris, \"jours\\n\")\n\nNombre de jours entre Tokyo et Paris : 1099 jours\n\n\nIl y a 1 099 jours entre les éditions de Tokyo en 2021 et de Paris en 2024\n\nsemaines_entre_rio_et_tokyo &lt;- as.numeric(difftime(tokyo_date, rio_date, units = \"weeks\"))\n\nsemaines_entre_tokyo_et_paris &lt;- as.numeric(difftime(paris_date, tokyo_date, units = \"weeks\"))\n\ncat(\"Nombre de semaines entre Rio et Tokyo :\", semaines_entre_rio_et_tokyo, \"semaines\\n\")\n\nNombre de semaines entre Rio et Tokyo : 259 semaines\n\ncat(\"Nombre de semaines entre Tokyo et Paris :\", semaines_entre_tokyo_et_paris, \"semaines\\n\")\n\nNombre de semaines entre Tokyo et Paris : 157 semaines\n\n\nLe nombre de semaine qui séparent les éditions de Rio et de Tokyo est de 259 semaines et entre Tokyo et Paris de 157 semaines."
  },
  {
    "objectID": "posts/post-with-code/exercice 3.html#exercice-3",
    "href": "posts/post-with-code/exercice 3.html#exercice-3",
    "title": "blog",
    "section": "",
    "text": "Ce dernier exercice nous a permis d’utiliser des bases de données différentes notamment json, parquet et sqlite. Nous avons, ici aussi, nettoyer et visualiser les différentes bases. Nous avons également utiliser le package lubridate afin de traiter des dates.\n\n\n\nlibrary(stringr)\n\nWarning: le package 'stringr' a été compilé avec la version R 4.3.2\n\nlibrary(lubridate)\nlibrary(arrow)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(jsonlite)\n\nWarning: le package 'jsonlite' a été compilé avec la version R 4.3.2\n\nlibrary(RSQLite)\n\n\n\n\n\n\n\ndata &lt;- list.files(\"data\")\n\nprint(data)\n\ncharacter(0)\n\nextensions &lt;- tools::file_ext(data)\n\nprint(extensions)\n\nlogical(0)\n\n\nIl y a 4 fichiers dans le dossier data dont un sous format sqlite, un autre json et enfin parquet.\n\n\n\n\n\n\n\ntokyo &lt;- read_parquet(\"C:/Users/mathi/OneDrive/Documents/M1 ECAP/Semestre 2/R avancé et Git/TD3/tokyo_athletes.parquet\")\n\ndim(tokyo)\n\n[1] 11085     3\n\n\nLa table tokyo comprend 11 085 lignes et 3 colonnes.\n\nsummary(tokyo)\n\n     Name               NOC             Discipline       \n Length:11085       Length:11085       Length:11085      \n Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character  \n\n\nLes 3 colonnes se nomment :\n- Name\n- NOC\n- Discipline\n\n\n\n\n\n\n\nolympics &lt;-read_json(\"C:/Users/mathi/OneDrive/Documents/M1 ECAP/Semestre 2/R avancé et Git/TD3/olympics_athletes.json\")\n\ndim(olympics)\n\nstr(olympics)\n\nIl y a 12 colonnes :\n- ID\n- Name\n- Sex\n- Age\n- Height\n- Weight\n- Team\n- NOC\n- Games\n- City\n- Sport\n- Event\n\n\n\n\n\n\n\nconnexion &lt;- dbConnect(drv=RSQLite::SQLite(), dbname=\"C:/Users/mathi/OneDrive/Documents/M1 ECAP/Semestre 2/R avancé et Git/TD3/data.sqlite\")\n\ntables &lt;- dbListTables(connexion)\n\ntables\n\n[1] \"olympics_athletes\" \"tokyo_athletes\"    \"tokyo_medals\"     \n[4] \"tokyo_teams\"      \n\n\nIci, cela contient :\n- olympics_athletes\n- tokyo_athletes\n- tokyo_medals\n- tokyo_teams\n\n\n\n\n\n\n\nif (dbIsValid(connexion)) {\n\n  \n\n  file_olympics &lt;- \"olympics_athletes.json\"\n\n  file_tokyo &lt;- \"tokyo_athletes.parquet\"\n\n  \n\n  tryCatch({\n\n    # Chargeons les données json avec read_json\n\n    data_olympics &lt;- read_json(file_olympics, simplifyVector = TRUE)\n\n    \n\n    #Convertissons les données en data.frame \n\n   \n\n   data_olympics_df &lt;- as.data.frame(data_olympics)\n\n    \n\n    # Utilisation dbWriteTable avec append=TRUE pour ajouter à la table déjà existante\n\n  dbWriteTable(connexion, \"olympics_athletes\", data_olympics_df, append = TRUE)\n\n    \n\n    # Utilisation dbWriteTable avec overwrite=TRUE pour écraser la table existante (sinon beug)\n\n  dbWriteTable(connexion, \"tokyo_athletes\", read_parquet(file_tokyo), overwrite = TRUE)\n\n  }, error = function(e) {\n\n    cat(\"Erreur lors de la lecture du fichier JSON :\", conditionMessage(e), \"\\n\")\n\n  })\n\n  \n\n  # Ne pas fermer la connexion ici \n\n} else {\n\n  cat(\"Erreur: La connexion à la base de données a échoué.\")\n\n}\n\n\n\n\n\n\n\n\nif (dbIsValid(connexion)) {\n\n  colonnes_olympics &lt;- dbListFields(connexion, \"olympics_athletes\")\n\n  print(colonnes_olympics)\n\n} else {\n\n  cat(\"Erreur: La connexion à la base de données a échoué.\")\n\n}\n\n [1] \"ID\"     \"Name\"   \"Sex\"    \"Age\"    \"Height\" \"Weight\" \"Team\"   \"NOC\"   \n [9] \"Games\"  \"City\"   \"Sport\"  \"Event\"  \"Medal\" \n\n\nLes colonnes sont les suivantes :\n- ID\n- Name\n- Sex\n- Age\n- Height\n- Weight\n- Team\n- NOC\n- Games\n- City\n- Sport\n- Event\n- Medal\n\n\n\n\n\n\nConvertissez la table en tibble en utilisant la fonction as_tibble.\n\nif (dbIsValid(connexion)) {\n\n  \n\n  nom_table &lt;- \"olympics_athletes\"\n\n  \n\n  #Importation la table depuis la base de données\n\n  table_importee &lt;- dbReadTable(connexion, nom_table)\n\n  \n\n  #Convertissons la table en tibble\n\n  tibble_resultat &lt;- as_tibble(table_importee)\n\n  \n\n  print(tibble_resultat)\n\n  \n\n} else {\n\n  cat(\"Erreur: La connexion à la base de données a échoué.\")\n\n}\n\n# A tibble: 1,078,924 × 13\n      ID Name      Sex     Age Height Weight Team  NOC   Games City  Sport Event\n   &lt;int&gt; &lt;chr&gt;     &lt;chr&gt; &lt;int&gt;  &lt;int&gt;  &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n 1     1 A Dijiang M        24    180     80 China CHN   1992… Barc… Bask… Bask…\n 2     2 A Lamusi  M        23    170     60 China CHN   2012… Lond… Judo  Judo…\n 3     3 Gunnar N… M        24     NA     NA Denm… DEN   1920… Antw… Foot… Foot…\n 4     4 Edgar Li… M        34     NA     NA Denm… DEN   1900… Paris Tug-… Tug-…\n 5     5 Christin… F        21    185     82 Neth… NED   1988… Calg… Spee… Spee…\n 6     5 Christin… F        21    185     82 Neth… NED   1988… Calg… Spee… Spee…\n 7     5 Christin… F        25    185     82 Neth… NED   1992… Albe… Spee… Spee…\n 8     5 Christin… F        25    185     82 Neth… NED   1992… Albe… Spee… Spee…\n 9     5 Christin… F        27    185     82 Neth… NED   1994… Lill… Spee… Spee…\n10     5 Christin… F        27    185     82 Neth… NED   1994… Lill… Spee… Spee…\n# ℹ 1,078,914 more rows\n# ℹ 1 more variable: Medal &lt;chr&gt;\n\n\n\n\n\n\n\n\n\n\n\n\ntibble_resultat &lt;- tibble_resultat|&gt; \n\n  mutate(Sex = as.factor(Sex))\n\nprint(tibble_resultat)\n\n\n\n\n\n\n\n\ntibble_resultat &lt;- tibble_resultat |&gt; \n\n  separate(Games, into = c(\"Year\", \"isSummer\"), sep = \" \", convert = TRUE)\n\n\nprint(tibble_resultat)\n\ntibble_resultat\n\n\n\n\n\n\n\n\n\n\n\nresultats_moyenne_age &lt;- tibble_resultat |&gt; \n\n  group_by(Year) |&gt; \n\n  summarise(moyenne_age = mean(Age, na.rm = TRUE))\n\n#Identification de l'édition avec les athlètes les plus jeunes\n\nplus_jeunes &lt;- resultats_moyenne_age |&gt; \n\n  filter(moyenne_age == min(moyenne_age, na.rm = TRUE))\n\n# Identification de l'édition avec les athlètes les plus vieux\n\nplus_vieux &lt;- resultats_moyenne_age |&gt;  \n\n  filter(moyenne_age == max(moyenne_age, na.rm = TRUE))\n\n\nprint(resultats_moyenne_age)\n\n# A tibble: 35 × 2\n    Year moyenne_age\n   &lt;int&gt;       &lt;dbl&gt;\n 1  1896        23.6\n 2  1900        28.9\n 3  1904        26.7\n 4  1906        27.1\n 5  1908        27.0\n 6  1912        27.5\n 7  1920        29.3\n 8  1924        28.0\n 9  1928        27.9\n10  1932        29.6\n# ℹ 25 more rows\n\n\n\nprint(plus_jeunes)\n\n# A tibble: 1 × 2\n   Year moyenne_age\n  &lt;int&gt;       &lt;dbl&gt;\n1  1896        23.6\n\n\nL’édition avec les athlètes les plus jeunes était en 1896 et la moyenne d’âge était de 23,6 ans\n\nprint(plus_vieux)\n\n# A tibble: 1 × 2\n   Year moyenne_age\n  &lt;int&gt;       &lt;dbl&gt;\n1  1932        29.6\n\n\nL’édition avec les athlètes les plus vieux était en 1932 et la moyenne d’âge était de 29,6 ans\n\n\n\n\n\n\n\nathletes_femmes &lt;- tibble_resultat |&gt; \n\n  filter(Sex == \"F\")\n\n#Remplacons les valeurs manquantes de Height par une valeur spécifique ici 0 pour simplifier\n\nathletes_femmes &lt;- athletes_femmes |&gt; \n\n  mutate(Height = ifelse(is.na(Height), 0, Height))\n\n#Regroupeons par discipline et par année, puis calculons la taille maximale des athlètes féminines\n\nplus_grande_taille_par_discipline &lt;- athletes_femmes |&gt; \n\n  group_by(Sport, Year, .groups = \"drop_last\") |&gt; \n\n  summarise(taille_max = max(Height, na.rm = TRUE), .groups = \"drop_last\")\n\n#Identification de la discipline avec la plus grande taille pour chaque année\n\nplus_grande_taille_discipline_par_annee &lt;- plus_grande_taille_par_discipline |&gt; \n\n  group_by(Year, .groups = \"drop_last\") |&gt; \n\n  filter(taille_max == max(taille_max, na.rm = TRUE), .groups == \"drop_last\")\n\n#Identification de la discipline qui a été la plus grande (en fonction de la fréquence)\n\ndiscipline_plus_grande_frequence &lt;- plus_grande_taille_discipline_par_annee |&gt; \n\n  group_by(Sport, .groups = \"drop_last\") |&gt; \n\n  summarise(frequence = n(), .groups = \"drop_last\")\n\n\nprint(\"Discipline des JO d'été avec la plus grande taille d'athlètes féminines par année :\")\n\nprint(plus_grande_taille_discipline_par_annee, n = 60)\n\nLa plus grande taille par discipline provient du Basketball avec 213cm\n\nprint(\"Discipline avec la plus grande taille d'athlètes féminines le plus souvent :\")\n\n[1] \"Discipline avec la plus grande taille d'athlètes féminines le plus souvent :\"\n\nprint(discipline_plus_grande_frequence, n = 60)\n\n# A tibble: 17 × 3\n# Groups:   Sport [17]\n   Sport          .groups   frequence\n   &lt;chr&gt;          &lt;chr&gt;         &lt;int&gt;\n 1 Archery        drop_last         2\n 2 Athletics      drop_last         6\n 3 Basketball     drop_last        11\n 4 Bobsleigh      drop_last         3\n 5 Croquet        drop_last         1\n 6 Diving         drop_last         2\n 7 Equestrianism  drop_last         1\n 8 Fencing        drop_last         4\n 9 Figure Skating drop_last         1\n10 Golf           drop_last         1\n11 Ice Hockey     drop_last         1\n12 Luge           drop_last         2\n13 Motorboating   drop_last         1\n14 Sailing        drop_last         2\n15 Swimming       drop_last         2\n16 Tennis         drop_last         5\n17 Volleyball     drop_last         3\n\n\nTout cela pour une frequence de 11.\n\n\n\n\n\ntexte &lt;- \"Les jeux olympiques d'été se déroulent normalement tous \n\nles 4 ans, durant les mois de Juillet et Août. \n\nLes jeux de Rio ont eu lieu du 5 Août 2016 au 20 Août 2016, \n\nceux de Tokyo du 23 Juillet 2021 au 8 Août 2021, \n\net ceux de Paris auront lieu du 26 Juillet 2024 au 11 Août 2024. \n\nPlus de 10000 athlètes sont attendus du monde entier à Paris.\"\n\n\n\n\n\n\n\n\n\n\n#Expression régulière pour capturer une date au format \"jour Mois année\"\n\nregex_date &lt;- \"\\\\b\\\\d{1,2} (Janvier|Février|Mars|Avril|Mai|Juin|Juillet|Août|Septembre|Octobre|Novembre|Décembre) \\\\d{4}\\\\b\"\n\n#Utilisaton str_extract_all pour extraire toutes les dates du texte\n\ndates &lt;- str_extract_all(texte, regex_date)[[1]]\n\nprint(dates)\n\n[1] \"5 Août 2016\"     \"20 Août 2016\"    \"23 Juillet 2021\" \"8 Août 2021\"    \n[5] \"26 Juillet 2024\" \"11 Août 2024\"   \n\n\n\n\n\n\n\n\n\nmois_en_numero &lt;- function(mois) {\n\n  mois &lt;- tolower(mois)\n\n  mois_numeros &lt;- c(\"janvier\", \"février\", \"mars\", \"avril\", \"mai\", \"juin\", \"juillet\", \"août\", \"septembre\", \"octobre\", \"novembre\", \"décembre\")\n\n  return(match(mois, mois_numeros))\n\n}\n\n#Remplaceons les noms des mois par leur numéro\n\ndates_numerotees &lt;- str_replace_all(dates, regex_date, function(match) {\n\n  elements &lt;- str_split(match, \" \")[[1]]\n\n  elements[2] &lt;- mois_en_numero(elements[2])\n\n  return(paste(elements, collapse = \" \"))\n\n})\n\nprint(dates_numerotees)\n\n[1] \"5 8 2016\"  \"20 8 2016\" \"23 7 2021\" \"8 8 2021\"  \"26 7 2024\" \"11 8 2024\"\n\n\n\n\n\n\n\n\n\nconvertir_en_date &lt;- function(date_texte) {\n\n  elements &lt;- str_split(date_texte, \" \")[[1]]\n\n  jour &lt;- as.integer(elements[1])\n\n  mois &lt;- as.integer(elements[2])\n\n  annee &lt;- as.integer(elements[3])\n\n  return(dmy(paste(jour, mois, annee, sep = \"-\")))\n\n}\n\n#Appliqueons la fonction à chaque élément de la liste\n\ndates_converties &lt;- sapply(dates_numerotees, convertir_en_date)\n\nprint(dates_converties)\n\n 5 8 2016 20 8 2016 23 7 2021  8 8 2021 26 7 2024 11 8 2024 \n    17018     17033     18831     18847     19930     19946 \n\n\n\n\n\n\n\n\n\n\n\n\nrio_date &lt;- dmy(\"5 Août 2016\")\n\ntokyo_date &lt;- dmy(\"23 Juillet 2021\")\n\nparis_date &lt;- dmy(\"26 Juillet 2024\")\n\n\njours_entre_rio_et_tokyo &lt;- as.numeric(difftime(tokyo_date, rio_date, units = \"days\"))\n\ncat(\"Nombre de jours entre Rio et Tokyo :\", jours_entre_rio_et_tokyo, \"jours\\n\")\n\nNombre de jours entre Rio et Tokyo : 1813 jours\n\n\nIl y a 1 813 jours entre les éditions de Rio en 2016 et de Tokyo en 2021\n\njours_entre_tokyo_et_paris &lt;- as.numeric(difftime(paris_date, tokyo_date, units = \"days\"))\n\ncat(\"Nombre de jours entre Tokyo et Paris :\", jours_entre_tokyo_et_paris, \"jours\\n\")\n\nNombre de jours entre Tokyo et Paris : 1099 jours\n\n\nIl y a 1 099 jours entre les éditions de Tokyo en 2021 et de Paris en 2024\n\nsemaines_entre_rio_et_tokyo &lt;- as.numeric(difftime(tokyo_date, rio_date, units = \"weeks\"))\n\nsemaines_entre_tokyo_et_paris &lt;- as.numeric(difftime(paris_date, tokyo_date, units = \"weeks\"))\n\ncat(\"Nombre de semaines entre Rio et Tokyo :\", semaines_entre_rio_et_tokyo, \"semaines\\n\")\n\nNombre de semaines entre Rio et Tokyo : 259 semaines\n\ncat(\"Nombre de semaines entre Tokyo et Paris :\", semaines_entre_tokyo_et_paris, \"semaines\\n\")\n\nNombre de semaines entre Tokyo et Paris : 157 semaines\n\n\nLe nombre de semaine qui séparent les éditions de Rio et de Tokyo est de 259 semaines et entre Tokyo et Paris de 157 semaines."
  },
  {
    "objectID": "posts/post-with-code/exercice 4.html",
    "href": "posts/post-with-code/exercice 4.html",
    "title": "blog",
    "section": "",
    "text": "Cet exercice, nous a permis d’établir notre package final olympicsWeather\n\n\n\n\n\ninstall.packages(\"devtools\")\ninstall.packages(\"httr2\")\ninstall.packages(\"jsonlite\")\ninstall.packages(\"usethis\")\ninstall.packages(\"htmltools\")\n\n\nlibrary(devtools)\n\nLe chargement a nécessité le package : usethis\n\nlibrary(httr2)\nlibrary(jsonlite)\n\nWarning: le package 'jsonlite' a été compilé avec la version R 4.3.2\n\nlibrary(tibble)\nlibrary(purrr)\n\n\nAttachement du package : 'purrr'\n\n\nL'objet suivant est masqué depuis 'package:jsonlite':\n\n    flatten\n\nlibrary(tidygeocoder)\nlibrary(usethis)\nlibrary(roxygen2)\nlibrary(usethis)\nlibrary(lubridate)\n\n\nAttachement du package : 'lubridate'\n\n\nLes objets suivants sont masqués depuis 'package:base':\n\n    date, intersect, setdiff, union\n\n\n\n\n\n\n\n\n\nusethis::create_package(\"olympicsWeather\")\n\n\n\n\n\n\n\n\nusethis::use_r(\"get_weather_forecast\")\n\n\n\n\n\n\n\n• l’url de l’api open-api est la suivante: https://api.open-meteo.com/v1/forecast\\\n• vous utiliserez les fonctions request, req_url_query, req_perform, resp_body_json pour passer la requête. Ces instructions peuvent se chaîner avec des pipes. La fonction request permet d’initialiser l’objet de request en passant l’url de l’api. La fonction req_url_query permet de passer différents paramètres à la requête, quand req_perform exécute la requête et récupère les résultats dans la session R. Enfin, la fonction resp_body_json extrait les données retournées en json du résultat de la requête. Vous pourrez utiliser la fonction tibble::as_tibble() pour convertir en tibble la table retournée.\\\n• pour la première requête, nous souhaitons obtenir la prévision météo aux coordonnées géographiques c(48.85, 2.35)\\\n•nous souhaitons obtenir les informations de températures, de températures ressenties, de probabilité de précipitation, et de quantités de précipitations. Indice, vous devrez passer le paramètre suivant (entre autres) hourly= c(“temperature_2m”, “apparent_temperature”, “precipitation_probability”, “precipitation”) à la fonction req_url_query\n\nurl &lt;- \"https://api.open-meteo.com/v1/forecast\"\n\n\nrequest(url) |&gt;\n\n  req_url_query(latitude=48.85,longitude=2.35, hourly=c(\"temperature_2m\",\"apparent_temperature\",\"precipitation_probability\", \"precipitation\"), .multi = \"comma\"\n\n  ) |&gt;\n\n  req_perform() |&gt;\n\n  resp_body_json() |&gt;\n\n  tibble::as_tibble() |&gt; View()\n\n\n\n\n\n\n\nSuite à notre requête, nous avons obtenus un tibble pour l’endroit se situant à la latitude 48.85 et la longitude 2.85.\nDans ce tibble, nous retrouvons donc une ligne correspondant à la date avec le fuseau horaire, la seconde ligne correspond aux températures, la troisième à l’humidité, la quatrième à la probabilité des précipitations et enfin la dernière aux précipitations comprenant la pluie, les averses et la neige (cf documentation : https://open-meteo.com/en/docs/)\n\n\n\n\n\n\nNous devons donc établir différentes fonctions :\n\n\n\n\n\n\n• la fonction perform request prend en entrée deux arguments: latitude et longitude\\\n• elle effectue la requête sur l’api publique ci-dessus, et retourne le contenu du body sous forme d’une tibble (exactement comme dans la question 4)\n\n#' Effectue une requête à l'API pour obtenir les prévisions météo.\n\n#'\n\n#' Cette fonction prend en entrée les coordonnées GPS (latitude, longitude) et retourne\n\n#' les prévisions météo sous forme de tibble.\n\n#'\n\n#' @param lat La latitude (numeric).\n\n#' @param lon La longitude (numeric).\n\n#'\n\n#' @export\n\nperform_request &lt;- function(lat, lon) {\n\n  url &lt;- \"https://api.open-meteo.com/v1/forecast\"\n\n    request(url) |&gt;\n\n    req_url_query(latitude=lat,longitude=lon, hourly= c(\"temperature_2m\",\"apparent_temperature\",\"precipitation_probability\",\"precipitation\"), .multi = \"comma\"\n\n    ) |&gt;\n\n    req_perform() |&gt;\n\n    resp_body_json() |&gt;\n\n    as_tibble ()\n\n}\n\n\nresp &lt;- perform_request(48.85, 2.35)\n\n\n\n\n\n\n\n• les résultats obtenus après la requête n’étant pas bien formattés, il faut écrire une fonction pour transformer la forme de la tibble obtenue\\\n• la fonction en entrée prendre une tibble au format issu de la requête\\\n• et retournera les mêmes données au schema suivant:\\\n-- date_heure: heure au tz UTC\\\n-- tempature_celsius: données de température\\\n-- temperature_ressentie_celsius: données de température ressentie\\\n-- precipation_proba: probabilité de pluie\\\n-- precipitation: precipitation en mm\n\n#' Transforme la tibble obtenue de la requête en une structure de données spécifique.\n\n#'\n\n#' Cette fonction prend en entrée la tibble obtenue de la requête et la transforme pour\n\n#' obtenir une nouvelle tibble avec les informations nécessaires.\n\n#'\n\n#' @param extraction sert a extraire les différentes colonnes de la liste de données\n\n#'\n\n#' @export\n\nunnest_response &lt;- function(extraction){\n\n  hourly_data &lt;- extraction$hourly\n\n  if (length(hourly_data) == 0) {\n\n    stop(\"Aucune donnée dans la colonne 'hourly'.\")\n\n  }\n\n  output_tibble &lt;- tibble(\n\n    \"date_heure\" = ymd_hm(unlist(hourly_data[[1]])),\n\n    \"temperature_celsius\" = unlist(hourly_data[[2]]),\n\n    \"temperature_ressentie_celsius\" = unlist(hourly_data[[3]]),\n\n    \"precipitation_proba\" = unlist(hourly_data[[4]]),\n\n    \"precipitation\" = unlist(hourly_data[[5]])\n\n  )\n\n}\n\n\nresp &lt;- perform_request(48.85, 2.35)\n\nunnested_table &lt;- unnest_response(resp)\n\n\nunnested_table\n\n\n\n\n\n\n\n• créez un script de tests en utilisant la fonction usethis::use_test(“unnest_response”)\\\n• dans ce script, créez un jeu de données minimal pour tester le comportement de la fonction\\\n• testez la fonction, en proposant plusieurs tests unitaires. Exemple de tests unitaires:\\\n-- testez que la fonction renvoie le bon nombre de lignes\\\n-- testez que les valeurs de la colonne temperature correspondent aux valeur proposées en entrée\\\n-- testez le nom des colonnes en sortie\\\n-- testez le nombre de colonnes en sortie\n\nusethis::use_test(\"unnest_response\")\n\nRésultat de cette commande :\n\ntest_that(\"multiplication works\", {\n\n  expect_equal(2 * 2, 4)\n\n})\n\n\n✔ Setting active project to 'C:/Users/mathi/OneDrive/Documents/M1 ECAP/Semestre 2/R avancé et Git/Exercice 4/olympicsWeather'\n\n✔ Adding 'testthat' to Suggests field in DESCRIPTION\n\n✔ Adding '3' to Config/testthat/edition\n\n✔ Creating 'tests/testthat/'\n\n✔ Writing 'tests/testthat.R'\n\n✔ Writing 'tests/testthat/test-unnest_response.R'\n\n• Modify 'tests/testthat/test-unnest_response.R'\n\nTest :\n\nlibrary(testthat)\n\n#Jeu de données \n\ncontext(\"unnest_response\")\n\nmock_data &lt;- tibble::tibble(\n\n  hourly = list(\n\n    list(\"2024-02-24 12:00:00\", \"2024-02-24 13:00:00\"),\n\n    list(22, 28),\n\n    list(17, 13),\n\n    list(0.7, 0.4),\n\n    list(0.9, 0.3)\n\n  )\n\n)\n\nmock_data_df &lt;- data.frame(do.call(cbind, mock_data$hourly))\n\ncolnames(mock_data_df) &lt;- c(\"date_heure\", \"temperature_celsius\", \"temperature_ressentie_celsius\", \"precipitation_proba\", \"precipitation\")\n\nprint(mock_data_df)\n\n#Test unitaire\n\n#Bon nombre de lignes\n\ntest_that(\"La fonction renvoie le bon nombre de lignes\", {\n\n  output_tibble &lt;- unnest_response(mock_data)\n\n  expect_equal(nrow(output_tibble), nrow(mock_data_df))\n\n})\n\n#Bonne température\n\ntest_that(\"La fonction renvoie le bon nombre de lignes\", {\n\n  output_tibble &lt;- unnest_response(mock_data)\n\n  expect_true(all(output_tibble[[2]] == mock_data_df[[2]]),\n\n              info = \"Les colonnes ne sont pas égales.\")\n\n})\n\n#Bon nom des colonnes \n\ntest_that(\"Les valeurs de la colonne temperature correspondent aux valeurs d'entrée\", {\n\n  output_tibble &lt;- unnest_response(mock_data)\n\n  expect_true(all.equal(names(output_tibble), names(mock_data_df)),\n\n              info = \"Les noms de colonnes ne sont pas égaux.\")\n\n})\n\n#Bon nombre de colonnes\n\ntest_that(\"Le nombre de colonnes en sortie est correct\", {\n\n  output_tibble &lt;- unnest_response(mock_data)\n\n  expect_equal(ncol(output_tibble), ncol(mock_data_df),\n\n               info = \"Le nombre de colonnes n'est pas égal.\")\n\n})\n\nusethis::use_test(\"unnest_response\")\n\ntest_file(\"tests/testthat/test-unnest_response.R »)\n\nRésultat du test : A l’aide de Rodolphe Mocaër\n\n#Library\n\n  library(testthat) \n\n#Jeu de données\n\n heure au tz UTC données de température\n\n1 2024-02-24 12:00:00                     20\n\n2 2024-02-24 13:00:00                     22\n\n  données de température ressentie probabilité de pluie\n\n1                               18                  0.2\n\n2                               20                  0.3\n\n  precipitation en mm\n\n1                 0.5\n\n2                 0.8\n\n#Test unitaire\n\n#Bon nombre de ligne\n\nTest passed \n\n#Bonne temperature\n\nTest passed \n\n#Bon nom de colonne \n\nTest passed  \n\n#Bon nombre de colonne \n\nTest passed  \n\nusethis::use_test(\"unnest_response\") \n\n✔ Setting active project to 'C:/Users/mathi/OneDrive/Documents/M1 ECAP/Semestre 2/R avancé et Git/Exercice 4/olympicsWeather'\n\n• Modify 'tests/testthat/test-unnest_response.R'\n\ntest_file(\"tests/testthat/test-unnest_response.R »)`\n\n\n\n\n\n\n\n• coordonnées GPS, i.e un vecteur numérique de taille 2\\\n• un nom de site olympique ou une adresse. A partir du code de la séance 1, définissez une fonction address_to_gps convertissant une adresse en coordonnées gps sous la forme d’un vecteur numérique de taille 2.\\\nDéfinir une fonction get_forecast générique, et deux implémentations get_forecast.character et get_forecast.numeric\n\n#' Convertit une adresse en coordonnées GPS.\n\n#'\n\n#' Cette fonction prend en entrée une adresse et renvoie les coordonnées GPS sous\n\n#' forme d'un vecteur numérique de taille 2.\n\n#'\n\n#' @param adresse Une adresse sous forme de texte.\n\n#'\n\n#' @return Un vecteur numérique de taille 2 avec les coordonnées GPS (latitude, longitude).\n\n#'\n\n#' @export\n\naddress_to_gps &lt;- function(adresse) {\n\n  df_adresse &lt;- data.frame(\"nom\" = character(), addr = character(), stringsAsFactors = FALSE)\n\n  df_adresse &lt;- rbind(df_adresse, data.frame(addr = adresse), stringsAsFactors = FALSE)\n\n  resultat_geocodage &lt;- df_adresse |&gt;\n\n    geocode(addr, method = 'arcgis')\n\n  df_adresse &lt;- resultat_geocodage\n\n}\n\n\nresultat_final &lt;- address_to_gps(\"9 Quai Henri Barbusse, Nantes, 44000, FRANCE\")\n\nPassing 1 address to the ArcGIS single address geocoder\n\n\nQuery completed in: 0.6 seconds\n\nprint(resultat_final)\n\n# A tibble: 1 × 3\n  addr                                           lat  long\n  &lt;chr&gt;                                        &lt;dbl&gt; &lt;dbl&gt;\n1 9 Quai Henri Barbusse, Nantes, 44000, FRANCE  47.2 -1.55\n\n\n\n\n\n\n\n\n\n#' Récupère les coordonnées GPS pour une adresse donnée.\n\n#'\n\n#' Cette fonction prend en entrée une adresse et renvoie les coordonnées GPS sous\n\n#' forme d'un vecteur numérique de taille 2 en utilisant la fonction address_to_gps.\n\n#'\n\n#' @param address Une adresse sous forme de texte.\n\n#'\n\n#' @return Un vecteur numérique de taille 2 avec les coordonnées GPS (latitude, longitude).\n\n#'\n\n#' @export\n\nget_gps_coordinate &lt;- function(address) {\n\n  coord_df &lt;- address_to_gps(address)\n\n  latitude &lt;- coord_df$lat\n\n  longitude &lt;- coord_df$long\n\n  coordinates &lt;- c(latitude[1], longitude[1])\n\n}\n\n\ncoordinates &lt;- get_gps_coordinate(\"9 Quai Henri Barbusse, Nantes, 44000, FRANCE\")\n\nPassing 1 address to the ArcGIS single address geocoder\n\n\nQuery completed in: 0.1 seconds\n\nprint(coordinates)\n\n[1] 47.224462 -1.552357\n\n\n\n\n\n\n\n\n\n\n#' Obtient les prévisions météo en fonction des coordonnées GPS.\n\n#'\n\n#' Cette fonction prend en entrée un vecteur numérique de taille 2 (latitude, longitude)\n\n#' et renvoie les prévisions météo sous forme de tibble.\n\n#'\n\n#' @param xy Un vecteur numérique de taille 2 représentant les coordonnées GPS.\n\n#'\n\n#' @return Un tibble avec les prévisions météo.\n\n#'\n\n#' @seealso \\code{\\link{perform_request}}, \\code{\\link{unnest_response}}\n\n#'\n\n#' @export\n\nget_forecast.numeric &lt;- function(xy) {\n\n  if (!is.numeric(xy) || length(xy) != 2) {\n\n    stop(\"L'argument xy doit être un vecteur numérique de taille 2 (latitude, longitude).\")\n\n  }\n\n  response_table &lt;- perform_request(xy[1], xy[2])\n\n  unnested_table &lt;- unnest_response(response_table)\n\n}\n\n\nxy_coordinates &lt;- c(48.85, 2.35)\n\nforecast_result &lt;- get_forecast.numeric(xy_coordinates)\n\nprint(forecast_result)\n\n# A tibble: 168 × 5\n   date_heure          temperature_celsius temperature_ressentie_celsius\n   &lt;dttm&gt;                            &lt;dbl&gt;                         &lt;dbl&gt;\n 1 2024-03-07 00:00:00                 4.7                           2.7\n 2 2024-03-07 01:00:00                 4.1                           1.7\n 3 2024-03-07 02:00:00                 3.7                           1.6\n 4 2024-03-07 03:00:00                 3                             0.8\n 5 2024-03-07 04:00:00                 2.7                           0.5\n 6 2024-03-07 05:00:00                 2.3                           0  \n 7 2024-03-07 06:00:00                 1.9                          -0.4\n 8 2024-03-07 07:00:00                 2                            -0.2\n 9 2024-03-07 08:00:00                 3.1                           1.1\n10 2024-03-07 09:00:00                 5.9                           3.8\n# ℹ 158 more rows\n# ℹ 2 more variables: precipitation_proba &lt;int&gt;, precipitation &lt;dbl&gt;\n\n\n\n\n\n\n\n\n#' Obtient les prévisions météo en fonction d'une adresse.\n\n#'\n\n#' Cette fonction prend en entrée une adresse, utilise la fonction address_to_gps\n\n#' pour obtenir les coordonnées GPS, puis appelle la fonction get_forecast.numeric.\n\n#'\n\n#' @param address Une adresse sous forme de texte.\n\n#'\n\n#' @return Un tibble avec les prévisions météo.\n\n#'\n\n#' @seealso \\code{\\link{address_to_gps}}, \\code{\\link{get_forecast.numeric}}\n\n#'\n\n#' @export\n\nget_forecast.character &lt;- function(address) {\n\n  if (!is.character(address) || length(address) != 1) {\n\n    stop(\"L'argument address doit être de type character et de taille 1.\")\n\n  }\n\n  coordinates &lt;- get_gps_coordinate(address)\n\n  response_table &lt;- perform_request(coordinates[1],coordinates[2])\n\n  unnested_table &lt;- unnest_response(response_table)\n\n}\n\n\nforecast_result &lt;- get_forecast.character(\"9 Quai Henri Barbusse, Nantes, 44000, FRANCE\")\n\nPassing 1 address to the ArcGIS single address geocoder\n\n\nQuery completed in: 0.1 seconds\n\nprint(forecast_result)\n\n# A tibble: 168 × 5\n   date_heure          temperature_celsius temperature_ressentie_celsius\n   &lt;dttm&gt;                            &lt;dbl&gt;                         &lt;dbl&gt;\n 1 2024-03-07 00:00:00                 6                             3.3\n 2 2024-03-07 01:00:00                 5.5                           2.6\n 3 2024-03-07 02:00:00                 6.4                           3  \n 4 2024-03-07 03:00:00                 5.8                           2.7\n 5 2024-03-07 04:00:00                 5.7                           2.5\n 6 2024-03-07 05:00:00                 4.9                           1.5\n 7 2024-03-07 06:00:00                 4                             0.4\n 8 2024-03-07 07:00:00                 3.9                           0.4\n 9 2024-03-07 08:00:00                 4.3                           0.5\n10 2024-03-07 09:00:00                 5.5                           1.2\n# ℹ 158 more rows\n# ℹ 2 more variables: precipitation_proba &lt;int&gt;, precipitation &lt;dbl&gt;\n\n\n\n\n\n\n\n\n\n#' Obtient les prévisions météo en fonction des coordonnées GPS ou de l'adresse.\n\n#'\n\n#' Cette fonction est générique et permet d'obtenir les prévisions météo en fonction des coordonnées GPS\n\n#' (latitude, longitude) ou d'une adresse spécifiée.\n\n#'\n\n#' @param x Un vecteur numérique de taille 2 représentant les coordonnées GPS (latitude, longitude).\n\n#' @param address Une adresse spécifiée en tant que caractère.\n\n#'\n\n#' @return Une tibble contenant les prévisions météo, comprenant la date, l'heure UTC, la température, la\n\n#' température ressentie, la probabilité de précipitation, et la quantité de précipitation.\n\n#'\n\n#' @seealso \\code{\\link{get_forecast.numeric}} et \\code{\\link{get_forecast.character}}\n\n#'\n\n#' @examples\n\n#' # Obtenir les prévisions météo pour des coordonnées GPS\n\n#' xy_coordinates &lt;- c(48.85, 2.35)\n\n#' forecast_result &lt;- get_forecast(xy_coordinates)\n\n#' print(forecast_result)\n\n#'\n\n#' # Obtenir les prévisions météo pour une adresse\n\n#' address_result &lt;- get_forecast(\"9 Quai Henri Barbusse, Nantes, 44000, FRANCE\")\n\n#' print(address_result)\n\n#'\n\n#' @export\n\n#' @param x Un vecteur numérique de taille 2 représentant les coordonnées GPS (latitude, longitude).\n\n#' @param address Une adresse spécifiée en tant que caractère.\n\n#' @return Une tibble contenant les prévisions météo.\n\nget_forecast &lt;- function(x) {\n\n  if (is.numeric(x)) {\n\n    result &lt;- get_forecast.numeric(x)\n\n  } else if (is.character(x)) {\n\n    result &lt;- get_forecast.character(x)\n\n  } else {\n\n    stop(\"L'un des arguments 'x' ou 'address' doit être spécifié.\")\n\n  }\n\n  print(graph_function(result))\n\n  return(result)\n\n}\n\n\n\n\n\n\n\n\nPackage: olympicsWeather\n\nTitle: Obtention des previsions meteo pour les sites olympiques\n\nVersion: 0.0.0.9000\n\nAuthor@R: person(\"JAMIN\", \"Mathilde\", email = \"mathilde.jamin@etu.univ-nantes.fr\", role = c(\"aut\", \"cre\"))\n\nDescription: Ce package fournit des fonctionnalites pour obtenir les previsions meteo en fonction des coordonnees GPS ou des adresses des sites olympiques.\n\nLicense: GPL-3\n\nEncoding: UTF-8\n\nRoxygen: list(markdown = TRUE)\n\nRoxygenNote: 7.3.1\n\nImports:\n\n    devtools,\n\n    httr2,\n\n    jsonlite,\n\n    tibble,\n\n    purrr,\n\n    tidygeocoder,\n\n    usethis,\n\n    roxygen2,\n\n    lubridate,\n\n    ggplot2\n\n\n# Generated by roxygen2: do not edit by hand\n\nexport(address_to_gps)\n\nexport(get_forecast)\n\nexport(get_forecast.character)\n\nexport(get_forecast.numeric)\n\nexport(get_gps_coordinate)\n\nexport(graph_function)\n\nexport(perform_request)\n\nexport(unnest_response)\n\n\n# Commande à réaliser dans la console :\n\n- document()\n\n- build()\n\n- devtools::install()\n\n\n\n\n\n\n\nNous pouvons proposer de faire un graphique avec ggplot, dans un autre script R relié au précédent.\n\nlibrary(ggplot2)\n\n#' Génère un graphique basé sur les données fournies.\n\n#'\n\n#' @param unnested_table Un tibble avec les données nécessaires pour le graphique.\n\n#' @return Un objet ggplot.\n\ngraph_function &lt;- function(unnested_table) {\n\n  ggplot(unnested_table, aes(x = as.POSIXct(date_heure), y = temperature_celsius)) +\n\n    geom_line(color = \"navy\", size = 1, linetype = \"solid\") +\n\n    labs(title = \"Évolution de la Température\",\n\n         x = \"Date et Heure (GMT)\",\n\n         y = \"Température (°C)\") +\n\n    theme_minimal()\n\n}"
  },
  {
    "objectID": "posts/post-with-code/exercice 4.html#exercice-4",
    "href": "posts/post-with-code/exercice 4.html#exercice-4",
    "title": "blog",
    "section": "",
    "text": "Cet exercice, nous a permis d’établir notre package final olympicsWeather\n\n\n\n\n\ninstall.packages(\"devtools\")\ninstall.packages(\"httr2\")\ninstall.packages(\"jsonlite\")\ninstall.packages(\"usethis\")\ninstall.packages(\"htmltools\")\n\n\nlibrary(devtools)\n\nLe chargement a nécessité le package : usethis\n\nlibrary(httr2)\nlibrary(jsonlite)\n\nWarning: le package 'jsonlite' a été compilé avec la version R 4.3.2\n\nlibrary(tibble)\nlibrary(purrr)\n\n\nAttachement du package : 'purrr'\n\n\nL'objet suivant est masqué depuis 'package:jsonlite':\n\n    flatten\n\nlibrary(tidygeocoder)\nlibrary(usethis)\nlibrary(roxygen2)\nlibrary(usethis)\nlibrary(lubridate)\n\n\nAttachement du package : 'lubridate'\n\n\nLes objets suivants sont masqués depuis 'package:base':\n\n    date, intersect, setdiff, union\n\n\n\n\n\n\n\n\n\nusethis::create_package(\"olympicsWeather\")\n\n\n\n\n\n\n\n\nusethis::use_r(\"get_weather_forecast\")\n\n\n\n\n\n\n\n• l’url de l’api open-api est la suivante: https://api.open-meteo.com/v1/forecast\\\n• vous utiliserez les fonctions request, req_url_query, req_perform, resp_body_json pour passer la requête. Ces instructions peuvent se chaîner avec des pipes. La fonction request permet d’initialiser l’objet de request en passant l’url de l’api. La fonction req_url_query permet de passer différents paramètres à la requête, quand req_perform exécute la requête et récupère les résultats dans la session R. Enfin, la fonction resp_body_json extrait les données retournées en json du résultat de la requête. Vous pourrez utiliser la fonction tibble::as_tibble() pour convertir en tibble la table retournée.\\\n• pour la première requête, nous souhaitons obtenir la prévision météo aux coordonnées géographiques c(48.85, 2.35)\\\n•nous souhaitons obtenir les informations de températures, de températures ressenties, de probabilité de précipitation, et de quantités de précipitations. Indice, vous devrez passer le paramètre suivant (entre autres) hourly= c(“temperature_2m”, “apparent_temperature”, “precipitation_probability”, “precipitation”) à la fonction req_url_query\n\nurl &lt;- \"https://api.open-meteo.com/v1/forecast\"\n\n\nrequest(url) |&gt;\n\n  req_url_query(latitude=48.85,longitude=2.35, hourly=c(\"temperature_2m\",\"apparent_temperature\",\"precipitation_probability\", \"precipitation\"), .multi = \"comma\"\n\n  ) |&gt;\n\n  req_perform() |&gt;\n\n  resp_body_json() |&gt;\n\n  tibble::as_tibble() |&gt; View()\n\n\n\n\n\n\n\nSuite à notre requête, nous avons obtenus un tibble pour l’endroit se situant à la latitude 48.85 et la longitude 2.85.\nDans ce tibble, nous retrouvons donc une ligne correspondant à la date avec le fuseau horaire, la seconde ligne correspond aux températures, la troisième à l’humidité, la quatrième à la probabilité des précipitations et enfin la dernière aux précipitations comprenant la pluie, les averses et la neige (cf documentation : https://open-meteo.com/en/docs/)\n\n\n\n\n\n\nNous devons donc établir différentes fonctions :\n\n\n\n\n\n\n• la fonction perform request prend en entrée deux arguments: latitude et longitude\\\n• elle effectue la requête sur l’api publique ci-dessus, et retourne le contenu du body sous forme d’une tibble (exactement comme dans la question 4)\n\n#' Effectue une requête à l'API pour obtenir les prévisions météo.\n\n#'\n\n#' Cette fonction prend en entrée les coordonnées GPS (latitude, longitude) et retourne\n\n#' les prévisions météo sous forme de tibble.\n\n#'\n\n#' @param lat La latitude (numeric).\n\n#' @param lon La longitude (numeric).\n\n#'\n\n#' @export\n\nperform_request &lt;- function(lat, lon) {\n\n  url &lt;- \"https://api.open-meteo.com/v1/forecast\"\n\n    request(url) |&gt;\n\n    req_url_query(latitude=lat,longitude=lon, hourly= c(\"temperature_2m\",\"apparent_temperature\",\"precipitation_probability\",\"precipitation\"), .multi = \"comma\"\n\n    ) |&gt;\n\n    req_perform() |&gt;\n\n    resp_body_json() |&gt;\n\n    as_tibble ()\n\n}\n\n\nresp &lt;- perform_request(48.85, 2.35)\n\n\n\n\n\n\n\n• les résultats obtenus après la requête n’étant pas bien formattés, il faut écrire une fonction pour transformer la forme de la tibble obtenue\\\n• la fonction en entrée prendre une tibble au format issu de la requête\\\n• et retournera les mêmes données au schema suivant:\\\n-- date_heure: heure au tz UTC\\\n-- tempature_celsius: données de température\\\n-- temperature_ressentie_celsius: données de température ressentie\\\n-- precipation_proba: probabilité de pluie\\\n-- precipitation: precipitation en mm\n\n#' Transforme la tibble obtenue de la requête en une structure de données spécifique.\n\n#'\n\n#' Cette fonction prend en entrée la tibble obtenue de la requête et la transforme pour\n\n#' obtenir une nouvelle tibble avec les informations nécessaires.\n\n#'\n\n#' @param extraction sert a extraire les différentes colonnes de la liste de données\n\n#'\n\n#' @export\n\nunnest_response &lt;- function(extraction){\n\n  hourly_data &lt;- extraction$hourly\n\n  if (length(hourly_data) == 0) {\n\n    stop(\"Aucune donnée dans la colonne 'hourly'.\")\n\n  }\n\n  output_tibble &lt;- tibble(\n\n    \"date_heure\" = ymd_hm(unlist(hourly_data[[1]])),\n\n    \"temperature_celsius\" = unlist(hourly_data[[2]]),\n\n    \"temperature_ressentie_celsius\" = unlist(hourly_data[[3]]),\n\n    \"precipitation_proba\" = unlist(hourly_data[[4]]),\n\n    \"precipitation\" = unlist(hourly_data[[5]])\n\n  )\n\n}\n\n\nresp &lt;- perform_request(48.85, 2.35)\n\nunnested_table &lt;- unnest_response(resp)\n\n\nunnested_table\n\n\n\n\n\n\n\n• créez un script de tests en utilisant la fonction usethis::use_test(“unnest_response”)\\\n• dans ce script, créez un jeu de données minimal pour tester le comportement de la fonction\\\n• testez la fonction, en proposant plusieurs tests unitaires. Exemple de tests unitaires:\\\n-- testez que la fonction renvoie le bon nombre de lignes\\\n-- testez que les valeurs de la colonne temperature correspondent aux valeur proposées en entrée\\\n-- testez le nom des colonnes en sortie\\\n-- testez le nombre de colonnes en sortie\n\nusethis::use_test(\"unnest_response\")\n\nRésultat de cette commande :\n\ntest_that(\"multiplication works\", {\n\n  expect_equal(2 * 2, 4)\n\n})\n\n\n✔ Setting active project to 'C:/Users/mathi/OneDrive/Documents/M1 ECAP/Semestre 2/R avancé et Git/Exercice 4/olympicsWeather'\n\n✔ Adding 'testthat' to Suggests field in DESCRIPTION\n\n✔ Adding '3' to Config/testthat/edition\n\n✔ Creating 'tests/testthat/'\n\n✔ Writing 'tests/testthat.R'\n\n✔ Writing 'tests/testthat/test-unnest_response.R'\n\n• Modify 'tests/testthat/test-unnest_response.R'\n\nTest :\n\nlibrary(testthat)\n\n#Jeu de données \n\ncontext(\"unnest_response\")\n\nmock_data &lt;- tibble::tibble(\n\n  hourly = list(\n\n    list(\"2024-02-24 12:00:00\", \"2024-02-24 13:00:00\"),\n\n    list(22, 28),\n\n    list(17, 13),\n\n    list(0.7, 0.4),\n\n    list(0.9, 0.3)\n\n  )\n\n)\n\nmock_data_df &lt;- data.frame(do.call(cbind, mock_data$hourly))\n\ncolnames(mock_data_df) &lt;- c(\"date_heure\", \"temperature_celsius\", \"temperature_ressentie_celsius\", \"precipitation_proba\", \"precipitation\")\n\nprint(mock_data_df)\n\n#Test unitaire\n\n#Bon nombre de lignes\n\ntest_that(\"La fonction renvoie le bon nombre de lignes\", {\n\n  output_tibble &lt;- unnest_response(mock_data)\n\n  expect_equal(nrow(output_tibble), nrow(mock_data_df))\n\n})\n\n#Bonne température\n\ntest_that(\"La fonction renvoie le bon nombre de lignes\", {\n\n  output_tibble &lt;- unnest_response(mock_data)\n\n  expect_true(all(output_tibble[[2]] == mock_data_df[[2]]),\n\n              info = \"Les colonnes ne sont pas égales.\")\n\n})\n\n#Bon nom des colonnes \n\ntest_that(\"Les valeurs de la colonne temperature correspondent aux valeurs d'entrée\", {\n\n  output_tibble &lt;- unnest_response(mock_data)\n\n  expect_true(all.equal(names(output_tibble), names(mock_data_df)),\n\n              info = \"Les noms de colonnes ne sont pas égaux.\")\n\n})\n\n#Bon nombre de colonnes\n\ntest_that(\"Le nombre de colonnes en sortie est correct\", {\n\n  output_tibble &lt;- unnest_response(mock_data)\n\n  expect_equal(ncol(output_tibble), ncol(mock_data_df),\n\n               info = \"Le nombre de colonnes n'est pas égal.\")\n\n})\n\nusethis::use_test(\"unnest_response\")\n\ntest_file(\"tests/testthat/test-unnest_response.R »)\n\nRésultat du test : A l’aide de Rodolphe Mocaër\n\n#Library\n\n  library(testthat) \n\n#Jeu de données\n\n heure au tz UTC données de température\n\n1 2024-02-24 12:00:00                     20\n\n2 2024-02-24 13:00:00                     22\n\n  données de température ressentie probabilité de pluie\n\n1                               18                  0.2\n\n2                               20                  0.3\n\n  precipitation en mm\n\n1                 0.5\n\n2                 0.8\n\n#Test unitaire\n\n#Bon nombre de ligne\n\nTest passed \n\n#Bonne temperature\n\nTest passed \n\n#Bon nom de colonne \n\nTest passed  \n\n#Bon nombre de colonne \n\nTest passed  \n\nusethis::use_test(\"unnest_response\") \n\n✔ Setting active project to 'C:/Users/mathi/OneDrive/Documents/M1 ECAP/Semestre 2/R avancé et Git/Exercice 4/olympicsWeather'\n\n• Modify 'tests/testthat/test-unnest_response.R'\n\ntest_file(\"tests/testthat/test-unnest_response.R »)`\n\n\n\n\n\n\n\n• coordonnées GPS, i.e un vecteur numérique de taille 2\\\n• un nom de site olympique ou une adresse. A partir du code de la séance 1, définissez une fonction address_to_gps convertissant une adresse en coordonnées gps sous la forme d’un vecteur numérique de taille 2.\\\nDéfinir une fonction get_forecast générique, et deux implémentations get_forecast.character et get_forecast.numeric\n\n#' Convertit une adresse en coordonnées GPS.\n\n#'\n\n#' Cette fonction prend en entrée une adresse et renvoie les coordonnées GPS sous\n\n#' forme d'un vecteur numérique de taille 2.\n\n#'\n\n#' @param adresse Une adresse sous forme de texte.\n\n#'\n\n#' @return Un vecteur numérique de taille 2 avec les coordonnées GPS (latitude, longitude).\n\n#'\n\n#' @export\n\naddress_to_gps &lt;- function(adresse) {\n\n  df_adresse &lt;- data.frame(\"nom\" = character(), addr = character(), stringsAsFactors = FALSE)\n\n  df_adresse &lt;- rbind(df_adresse, data.frame(addr = adresse), stringsAsFactors = FALSE)\n\n  resultat_geocodage &lt;- df_adresse |&gt;\n\n    geocode(addr, method = 'arcgis')\n\n  df_adresse &lt;- resultat_geocodage\n\n}\n\n\nresultat_final &lt;- address_to_gps(\"9 Quai Henri Barbusse, Nantes, 44000, FRANCE\")\n\nPassing 1 address to the ArcGIS single address geocoder\n\n\nQuery completed in: 0.6 seconds\n\nprint(resultat_final)\n\n# A tibble: 1 × 3\n  addr                                           lat  long\n  &lt;chr&gt;                                        &lt;dbl&gt; &lt;dbl&gt;\n1 9 Quai Henri Barbusse, Nantes, 44000, FRANCE  47.2 -1.55\n\n\n\n\n\n\n\n\n\n#' Récupère les coordonnées GPS pour une adresse donnée.\n\n#'\n\n#' Cette fonction prend en entrée une adresse et renvoie les coordonnées GPS sous\n\n#' forme d'un vecteur numérique de taille 2 en utilisant la fonction address_to_gps.\n\n#'\n\n#' @param address Une adresse sous forme de texte.\n\n#'\n\n#' @return Un vecteur numérique de taille 2 avec les coordonnées GPS (latitude, longitude).\n\n#'\n\n#' @export\n\nget_gps_coordinate &lt;- function(address) {\n\n  coord_df &lt;- address_to_gps(address)\n\n  latitude &lt;- coord_df$lat\n\n  longitude &lt;- coord_df$long\n\n  coordinates &lt;- c(latitude[1], longitude[1])\n\n}\n\n\ncoordinates &lt;- get_gps_coordinate(\"9 Quai Henri Barbusse, Nantes, 44000, FRANCE\")\n\nPassing 1 address to the ArcGIS single address geocoder\n\n\nQuery completed in: 0.1 seconds\n\nprint(coordinates)\n\n[1] 47.224462 -1.552357\n\n\n\n\n\n\n\n\n\n\n#' Obtient les prévisions météo en fonction des coordonnées GPS.\n\n#'\n\n#' Cette fonction prend en entrée un vecteur numérique de taille 2 (latitude, longitude)\n\n#' et renvoie les prévisions météo sous forme de tibble.\n\n#'\n\n#' @param xy Un vecteur numérique de taille 2 représentant les coordonnées GPS.\n\n#'\n\n#' @return Un tibble avec les prévisions météo.\n\n#'\n\n#' @seealso \\code{\\link{perform_request}}, \\code{\\link{unnest_response}}\n\n#'\n\n#' @export\n\nget_forecast.numeric &lt;- function(xy) {\n\n  if (!is.numeric(xy) || length(xy) != 2) {\n\n    stop(\"L'argument xy doit être un vecteur numérique de taille 2 (latitude, longitude).\")\n\n  }\n\n  response_table &lt;- perform_request(xy[1], xy[2])\n\n  unnested_table &lt;- unnest_response(response_table)\n\n}\n\n\nxy_coordinates &lt;- c(48.85, 2.35)\n\nforecast_result &lt;- get_forecast.numeric(xy_coordinates)\n\nprint(forecast_result)\n\n# A tibble: 168 × 5\n   date_heure          temperature_celsius temperature_ressentie_celsius\n   &lt;dttm&gt;                            &lt;dbl&gt;                         &lt;dbl&gt;\n 1 2024-03-07 00:00:00                 4.7                           2.7\n 2 2024-03-07 01:00:00                 4.1                           1.7\n 3 2024-03-07 02:00:00                 3.7                           1.6\n 4 2024-03-07 03:00:00                 3                             0.8\n 5 2024-03-07 04:00:00                 2.7                           0.5\n 6 2024-03-07 05:00:00                 2.3                           0  \n 7 2024-03-07 06:00:00                 1.9                          -0.4\n 8 2024-03-07 07:00:00                 2                            -0.2\n 9 2024-03-07 08:00:00                 3.1                           1.1\n10 2024-03-07 09:00:00                 5.9                           3.8\n# ℹ 158 more rows\n# ℹ 2 more variables: precipitation_proba &lt;int&gt;, precipitation &lt;dbl&gt;\n\n\n\n\n\n\n\n\n#' Obtient les prévisions météo en fonction d'une adresse.\n\n#'\n\n#' Cette fonction prend en entrée une adresse, utilise la fonction address_to_gps\n\n#' pour obtenir les coordonnées GPS, puis appelle la fonction get_forecast.numeric.\n\n#'\n\n#' @param address Une adresse sous forme de texte.\n\n#'\n\n#' @return Un tibble avec les prévisions météo.\n\n#'\n\n#' @seealso \\code{\\link{address_to_gps}}, \\code{\\link{get_forecast.numeric}}\n\n#'\n\n#' @export\n\nget_forecast.character &lt;- function(address) {\n\n  if (!is.character(address) || length(address) != 1) {\n\n    stop(\"L'argument address doit être de type character et de taille 1.\")\n\n  }\n\n  coordinates &lt;- get_gps_coordinate(address)\n\n  response_table &lt;- perform_request(coordinates[1],coordinates[2])\n\n  unnested_table &lt;- unnest_response(response_table)\n\n}\n\n\nforecast_result &lt;- get_forecast.character(\"9 Quai Henri Barbusse, Nantes, 44000, FRANCE\")\n\nPassing 1 address to the ArcGIS single address geocoder\n\n\nQuery completed in: 0.1 seconds\n\nprint(forecast_result)\n\n# A tibble: 168 × 5\n   date_heure          temperature_celsius temperature_ressentie_celsius\n   &lt;dttm&gt;                            &lt;dbl&gt;                         &lt;dbl&gt;\n 1 2024-03-07 00:00:00                 6                             3.3\n 2 2024-03-07 01:00:00                 5.5                           2.6\n 3 2024-03-07 02:00:00                 6.4                           3  \n 4 2024-03-07 03:00:00                 5.8                           2.7\n 5 2024-03-07 04:00:00                 5.7                           2.5\n 6 2024-03-07 05:00:00                 4.9                           1.5\n 7 2024-03-07 06:00:00                 4                             0.4\n 8 2024-03-07 07:00:00                 3.9                           0.4\n 9 2024-03-07 08:00:00                 4.3                           0.5\n10 2024-03-07 09:00:00                 5.5                           1.2\n# ℹ 158 more rows\n# ℹ 2 more variables: precipitation_proba &lt;int&gt;, precipitation &lt;dbl&gt;\n\n\n\n\n\n\n\n\n\n#' Obtient les prévisions météo en fonction des coordonnées GPS ou de l'adresse.\n\n#'\n\n#' Cette fonction est générique et permet d'obtenir les prévisions météo en fonction des coordonnées GPS\n\n#' (latitude, longitude) ou d'une adresse spécifiée.\n\n#'\n\n#' @param x Un vecteur numérique de taille 2 représentant les coordonnées GPS (latitude, longitude).\n\n#' @param address Une adresse spécifiée en tant que caractère.\n\n#'\n\n#' @return Une tibble contenant les prévisions météo, comprenant la date, l'heure UTC, la température, la\n\n#' température ressentie, la probabilité de précipitation, et la quantité de précipitation.\n\n#'\n\n#' @seealso \\code{\\link{get_forecast.numeric}} et \\code{\\link{get_forecast.character}}\n\n#'\n\n#' @examples\n\n#' # Obtenir les prévisions météo pour des coordonnées GPS\n\n#' xy_coordinates &lt;- c(48.85, 2.35)\n\n#' forecast_result &lt;- get_forecast(xy_coordinates)\n\n#' print(forecast_result)\n\n#'\n\n#' # Obtenir les prévisions météo pour une adresse\n\n#' address_result &lt;- get_forecast(\"9 Quai Henri Barbusse, Nantes, 44000, FRANCE\")\n\n#' print(address_result)\n\n#'\n\n#' @export\n\n#' @param x Un vecteur numérique de taille 2 représentant les coordonnées GPS (latitude, longitude).\n\n#' @param address Une adresse spécifiée en tant que caractère.\n\n#' @return Une tibble contenant les prévisions météo.\n\nget_forecast &lt;- function(x) {\n\n  if (is.numeric(x)) {\n\n    result &lt;- get_forecast.numeric(x)\n\n  } else if (is.character(x)) {\n\n    result &lt;- get_forecast.character(x)\n\n  } else {\n\n    stop(\"L'un des arguments 'x' ou 'address' doit être spécifié.\")\n\n  }\n\n  print(graph_function(result))\n\n  return(result)\n\n}\n\n\n\n\n\n\n\n\nPackage: olympicsWeather\n\nTitle: Obtention des previsions meteo pour les sites olympiques\n\nVersion: 0.0.0.9000\n\nAuthor@R: person(\"JAMIN\", \"Mathilde\", email = \"mathilde.jamin@etu.univ-nantes.fr\", role = c(\"aut\", \"cre\"))\n\nDescription: Ce package fournit des fonctionnalites pour obtenir les previsions meteo en fonction des coordonnees GPS ou des adresses des sites olympiques.\n\nLicense: GPL-3\n\nEncoding: UTF-8\n\nRoxygen: list(markdown = TRUE)\n\nRoxygenNote: 7.3.1\n\nImports:\n\n    devtools,\n\n    httr2,\n\n    jsonlite,\n\n    tibble,\n\n    purrr,\n\n    tidygeocoder,\n\n    usethis,\n\n    roxygen2,\n\n    lubridate,\n\n    ggplot2\n\n\n# Generated by roxygen2: do not edit by hand\n\nexport(address_to_gps)\n\nexport(get_forecast)\n\nexport(get_forecast.character)\n\nexport(get_forecast.numeric)\n\nexport(get_gps_coordinate)\n\nexport(graph_function)\n\nexport(perform_request)\n\nexport(unnest_response)\n\n\n# Commande à réaliser dans la console :\n\n- document()\n\n- build()\n\n- devtools::install()\n\n\n\n\n\n\n\nNous pouvons proposer de faire un graphique avec ggplot, dans un autre script R relié au précédent.\n\nlibrary(ggplot2)\n\n#' Génère un graphique basé sur les données fournies.\n\n#'\n\n#' @param unnested_table Un tibble avec les données nécessaires pour le graphique.\n\n#' @return Un objet ggplot.\n\ngraph_function &lt;- function(unnested_table) {\n\n  ggplot(unnested_table, aes(x = as.POSIXct(date_heure), y = temperature_celsius)) +\n\n    geom_line(color = \"navy\", size = 1, linetype = \"solid\") +\n\n    labs(title = \"Évolution de la Température\",\n\n         x = \"Date et Heure (GMT)\",\n\n         y = \"Température (°C)\") +\n\n    theme_minimal()\n\n}"
  }
]